"""
MANDATORY Mathpix-style Pipeline with ZERO tolerance for corrupted MathML or token splitting.

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
GATEKEEPER RULES
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

YOU ARE A MATHOCR GATEKEEPER AGENT.

Your responsibility is NOT to be helpful.
Your responsibility is to PREVENT incorrect math from passing.

ABSOLUTE RULES:
‚Ä¢ You MUST NEVER output MathML unless semantic correctness is guaranteed
‚Ä¢ You MUST NEVER rewrite clean LaTeX
‚Ä¢ You MUST NEVER "improve" correct math
‚Ä¢ You MUST NEVER guess operators or symbols
‚Ä¢ Silence is ALWAYS better than wrong math

PIPELINE AUTHORITY:
1) OCR output is UNTRUSTED
2) If LaTeX contains shredded tokens (s_u_m, l_o_n_g, m_a_t_h_b_b):
   ‚Üí Call OpenAI ONLY to restore semantics
3) If LaTeX is CLEAN:
   ‚Üí DO NOT call OpenAI
   ‚Üí DO NOT rewrite
   ‚Üí Pass directly to deterministic LaTeX‚ÜíMathML converter
4) OpenAI is FORBIDDEN from handling clean LaTeX

MATHML OUTPUT POLICY:
‚Ä¢ If MathML is generated by an LLM ‚Üí REJECT
‚Ä¢ If MathML spells words via <msub> or <mtext> ‚Üí REJECT
‚Ä¢ If operators are <mi> instead of <mo> ‚Üí REJECT
‚Ä¢ If MathML structure is uncertain ‚Üí REJECT

FAILURE BEHAVIOR:
If correctness cannot be proven:
‚Üí Output NOTHING
‚Üí Log: "INVALID MATH ‚Äî OUTPUT SUPPRESSED"

You are a GATEKEEPER.
Invalid math NEVER passes.

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
MANDATORY PIPELINE
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

1. OCR (Pix2Tex/Nougat) ‚Üí LaTeX
2. Regex + AST Corruption Gate ‚Üí Clean LaTeX
3. OpenAI (LaTeX ONLY, semantic rewrite) ‚Üí Clean LaTeX (ONLY if corrupted)
4. STRICT LaTeX Validator
5. YOUR OWN LaTeX ‚Üí MathML compiler (deterministic latex2mathml)
6. MathML Validator (zero tolerance)
7. GATEKEEPER FINAL VALIDATION ‚Üí REJECT if uncertain

üö´ CRITICAL RULES - OpenAI Usage:
- OpenAI is ONLY used for LaTeX semantic rewriting (ONLY when corrupted)
- OpenAI MUST NOT generate MathML
- OpenAI MUST NOT fix MathML
- OpenAI MUST NOT convert LaTeX ‚Üí MathML
- OpenAI is FORBIDDEN from handling clean LaTeX
- MathML MUST come from deterministic LaTeX‚ÜíMathML compiler (latex2mathml) ONLY

STRICT RULES:
- NEVER output MathML that spells words using subscripts
- NEVER guess symbols
- NEVER output LLM-generated MathML
- NEVER output MathML with operators in <mi> instead of <mo>
- Prefer semantic correctness over OCR confidence
- Follow W3C MathML and Mathpix conventions
- ZERO tolerance for corruption
- If MathML validation fails ‚Üí retry LaTeX semantic rewrite OR reject (NEVER ask OpenAI to fix MathML)
- If uncertain ‚Üí Output NOTHING (Silence is better than wrong math)
"""

from __future__ import annotations

import re
from typing import Literal, Optional, TypedDict, List, Tuple
from latex2mathml.converter import convert as latex2mathml_convert

from core.logger import logger


# ============================================================================
# CORRUPTION DETECTORS (STRICT)
# ============================================================================

def mathml_has_spelled_words(mathml: str) -> Tuple[bool, List[str]]:
    """
    REQUIRED: AST-level check for MathML spelling abuse.
    
    Detects if MathML contains spelled words via single-letter msub chains:
    - <msub><mi>l</mi><mrow><mi>o</mi></mrow></msub><msub><mi>n</mi><mrow><mi>g</mi></mrow></msub>
    - <msub><mi>r</mi><mrow><mi>i</mi></mrow></msub><msub><mi>g</mi><mrow><mi>h</mi></mrow></msub>
    - <msub><mi>s</mi><mi>u</mi></msub><mi>m</mi>
    
    Returns: (has_spelled_words, list_of_violations)
    """
    if not mathml:
        return False, []
    
    violations = []
    
    # Known words that are often spelled via msub: long, right, arrow, sum, equiv, mathbb, in, forall
    # Pattern must handle both <mi>Y</mi> and <mrow><mi>Y</mi></mrow> in subscript
    # Use re.DOTALL to match across newlines
    word_patterns = [
        # "long" spelled as: l_o n_g (handles both <mi>o</mi> and <mrow><mi>o</mi></mrow>)
        (r'<msub><mi>l</mi>.*?<mi>o</mi>.*?</msub>.*?<msub><mi>n</mi>.*?<mi>g</mi>.*?</msub>', 'STRICTLY FORBIDDEN: "long" spelled via msub chains (l_o n_g)'),
        # "right" spelled as: r_i g_h t
        (r'<msub><mi>r</mi>.*?<mi>i</mi>.*?</msub>.*?<msub><mi>g</mi>.*?<mi>h</mi>.*?</msub>.*?<mi>t</mi>', 'STRICTLY FORBIDDEN: "right" spelled via msub chains (r_i g_h t)'),
        # "arrow" spelled as: a_r r_o w
        (r'<msub><mi>a</mi>.*?<mi>r</mi>.*?</msub>.*?<msub><mi>r</mi>.*?<mi>o</mi>.*?</msub>.*?<mi>w</mi>', 'STRICTLY FORBIDDEN: "arrow" spelled via msub chains (a_r r_o w)'),
        # "sum" spelled as: s_u m
        (r'<msub><mi>s</mi>.*?<mi>u</mi>.*?</msub>.*?<mi>m</mi>', 'STRICTLY FORBIDDEN: "sum" spelled via msub chains (s_u m)'),
        # "equiv" spelled as: e_q u_i v
        (r'<msub><mi>e</mi>.*?<mi>q</mi>.*?</msub>.*?<msub><mi>u</mi>.*?<mi>i</mi>.*?</msub>.*?<mi>v</mi>', 'STRICTLY FORBIDDEN: "equiv" spelled via msub chains (e_q u_i v)'),
        # "mathbb" spelled as: m_a t_h b_b
        (r'<msub><mi>m</mi>.*?<mi>a</mi>.*?</msub>.*?<msub><mi>t</mi>.*?<mi>h</mi>.*?</msub>.*?<msub><mi>b</mi>.*?<mi>b</mi>.*?</msub>', 'STRICTLY FORBIDDEN: "mathbb" spelled via msub chains (m_a t_h b_b)'),
        # "in" spelled as: i_n
        (r'<msub><mi>i</mi>.*?<mi>n</mi>.*?</msub>(?!\s*<)', 'STRICTLY FORBIDDEN: "in" spelled via msub (i_n)'),
        # "forall" spelled as: f_o r_a l_l
        (r'<msub><mi>f</mi>.*?<mi>o</mi>.*?</msub>.*?<msub><mi>r</mi>.*?<mi>a</mi>.*?</msub>.*?<msub><mi>l</mi>.*?<mi>l</mi>.*?</msub>', 'STRICTLY FORBIDDEN: "forall" spelled via msub chains (f_o r_a l_l)'),
    ]
    
    for pattern, violation in word_patterns:
        if re.search(pattern, mathml, re.IGNORECASE | re.DOTALL):
            violations.append(violation)
    
    # Generic pattern: 3+ consecutive single-letter msub elements
    consecutive_msub_pattern = r'(?:<msub><mi>[a-zA-Z]</mi>.*?<mi>[a-zA-Z]</mi>.*?</msub>\s*){3,}'
    if re.search(consecutive_msub_pattern, mathml, re.IGNORECASE):
        violations.append('STRICTLY FORBIDDEN: 3+ consecutive single-letter msub elements (spelling abuse)')
    
    # Check for fake subscripts (plain text words in <msub>)
    fake_subscript_pattern = r'<msub><mi>([a-z]{2,})</mi>'
    matches = re.findall(fake_subscript_pattern, mathml, re.IGNORECASE)
    invalid_words = ['left', 'right', 'sum', 'frac', 'math', 'long', 'text', 'arrow', 'equiv', 'mathbb', 'forall']
    for match in matches:
        if match.lower() in invalid_words:
            violations.append(f'STRICTLY FORBIDDEN: word "{match}" in <msub> (should not be subscript)')
    
    return len(violations) > 0, violations


def is_corrupted_mathml(mathml: str) -> bool:
    """
    Validate MathML for corruption patterns.
    
    Bad patterns:
    - <msub><mi>l</mi> (split "left" or "long")
    - <msub><mi>s</mi> (split "sum")
    - "long" (corrupted operator)
    - "math b" (corrupted \\mathbb)
    - Letter-splitting of operators
    - Fake subscripts for plain text words
    
    This is the main validation function that must be called.
    """
    if not mathml or '<math' not in mathml:
        return False
    
    bad_patterns = [
        "<msub><mi>l</mi>",  # Split "left" or "long"
        "<msub><mi>s</mi>",  # Split "sum"
        "long",  # Corrupted operator
        "math b",  # Corrupted \mathbb
        "<mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi>",  # Split "left"
        "<mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi>",  # Split "right"
        "<mi>s</mi><mi>u</mi><mi>m</mi>",  # Split "sum"
        "<mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi>",  # Split "frac"
        "<mi>m</mi><mi>a</mi><mi>t</mi><mi>h</mi>",  # Split "math"
        "[object Object]",  # JavaScript error pattern (CORRUPTED)
    ]
    
    # Check for bad patterns
    for pattern in bad_patterns:
        if pattern in mathml:
            return True
    
    # Check for letter-splitting of operators (4+ consecutive single-char <mi> tags)
    # This indicates words being spelled letter-by-letter (CORRUPTED)
    if re.search(r'(?:<mi>\s*[a-zA-Z]\s*</mi>\s*){4,}', mathml):
        return True
    
    # Check for repeated single-letter subscripts forming words (CORRUPTED)
    # Pattern: <msub><mi>X</mi><mi>Y</mi></msub> repeated 3+ times
    if re.search(r'(?:<msub><mi>[a-z]</mi><mi>[a-z]</mi></msub>\s*){3,}', mathml, re.IGNORECASE):
        return True
    
    # Check for msub chains spelling "equiv", "sum", "mathbb" (CORRUPTED)
    equiv_chain = r'<msub><mi>e</mi><mi>q</mi></msub>.*?<msub><mi>u</mi><mi>i</mi></msub>.*?<mi>v</mi>'
    sum_chain = r'<msub><mi>s</mi><mi>u</mi></msub>.*?<mi>m</mi>'
    mathbb_chain = r'<msub><mi>m</mi><mi>a</mi></msub>.*?<msub><mi>t</mi><mi>h</mi></msub>.*?<msub><mi>b</mi><mi>b</mi></msub>'
    
    if re.search(equiv_chain, mathml, re.IGNORECASE):
        return True
    if re.search(sum_chain, mathml, re.IGNORECASE):
        return True
    if re.search(mathbb_chain, mathml, re.IGNORECASE):
        return True
    
    # Check for fake subscripts (plain text words in <msub>)
    # Pattern: <msub><mi>word</mi> where word is longer than 1 char and not a math symbol
    fake_subscript_pattern = r'<msub><mi>([a-z]{2,})</mi>'
    matches = re.findall(fake_subscript_pattern, mathml, re.IGNORECASE)
    # Common math words that should NOT be in <msub> as plain text
    invalid_words = ['left', 'right', 'sum', 'frac', 'math', 'long', 'text']
    for match in matches:
        if match.lower() in invalid_words:
            return True
    
    return False


def validate_mathml_strict(mathml: str) -> Tuple[bool, List[str]]:
    """
    MANDATORY: Strict MathML validation with ZERO tolerance.
    
    The MathML is INVALID if ANY of the following occur:
    ‚ùå msub used to spell words
    ‚ùå "equiv", "sum", "mathbb" spelled via letters
    ‚ùå Operators represented as <mi>
    ‚ùå Human-readable words embedded in MathML
    ‚ùå MathML fails MathJax rendering
    
    Rules:
    1. NEVER spell words using <msub> (e.g., <msub><mi>l</mi><mi>e</mi></msub> for "left")
    2. Operators MUST use <mo> (not <mi>)
    3. Use <munderover> or <munder> for summations (not <msub>)
    4. Use ‚Ñ§, ‚àà, ‚àë semantically (Unicode entities or proper tags)
    5. MathML must render correctly in MathJax
    6. W3C MathML compliant
    
    Returns: (is_valid, list_of_violations)
    """
    if not mathml or '<math' not in mathml:
        return False, ['Empty or invalid MathML']
    
    # CRITICAL: Reject empty or minimal MathML (e.g., just <mtable />)
    # This happens when LaTeX conversion fails but produces "valid" empty structure
    mathml_content = re.sub(r'<[^>]+>', '', mathml)  # Remove all tags
    mathml_content = re.sub(r'\s+', '', mathml_content)  # Remove whitespace
    
    # Check for empty MathML structures
    if not mathml_content or len(mathml_content) == 0:
        # Check if it's just structural tags with no content
        structural_only_patterns = [
            r'<math[^>]*>\s*<mtable[^>]*/>\s*</math>',  # Empty table
            r'<math[^>]*>\s*<mrow[^>]*/>\s*</math>',  # Empty row
            r'<math[^>]*>\s*</math>',  # Completely empty
        ]
        for pattern in structural_only_patterns:
            if re.search(pattern, mathml, re.IGNORECASE | re.DOTALL):
                return False, ['INVALID: Empty or minimal MathML (no mathematical content)']
    
    # Check for MathML that's too short to contain real math (likely empty structure)
    # Real MathML should have at least some content (numbers, identifiers, operators)
    if len(mathml_content) < 3:  # Less than 3 characters of actual content
        # Check if it contains any actual math elements
        has_math_content = bool(
            re.search(r'<mi[^>]*>', mathml) or
            re.search(r'<mn[^>]*>', mathml) or
            re.search(r'<mo[^>]*>', mathml) or
            re.search(r'<mfrac', mathml) or
            re.search(r'<msup', mathml) or
            re.search(r'<msub', mathml)
        )
        if not has_math_content:
            return False, ['INVALID: MathML contains no mathematical content (empty structure)']
    
    violations = []
    
    # Rule 1: STRICTLY FORBIDDEN - NEVER encode words using <msub> (MANDATORY)
    # Examples: s_u m, e_q u_i v - STRICTLY FORBIDDEN
    # Check for repeated single-letter subscripts forming words (CORRUPTED)
    # Pattern: <msub><mi>X</mi><mi>Y</mi></msub> repeated to spell words
    repeated_subscript_words = [
        # "equiv" spelled as msub chains: e_q u_i v (STRICTLY FORBIDDEN)
        (r'(?:<msub><mi>e</mi><mi>q</mi></msub>.*?<msub><mi>u</mi><mi>i</mi></msub>.*?<mi>v</mi>)|(?:<msub><mi>e</mi><mi>q</mi></msub>.*?<mi>u</mi>.*?<msub><mi>i</mi><mi>v</mi></msub>)', 'STRICTLY FORBIDDEN: "equiv" spelled via repeated single-letter <msub> chains (e_q u_i v)'),
        # "sum" spelled as msub chains: s_u m (STRICTLY FORBIDDEN)
        (r'<msub><mi>s</mi><mi>u</mi></msub>.*?<mi>m</mi>', 'STRICTLY FORBIDDEN: "sum" spelled via repeated single-letter <msub> chains (s_u m)'),
        # "mathbb" spelled as msub chains: m_a t_h b_b (STRICTLY FORBIDDEN)
        (r'<msub><mi>m</mi><mi>a</mi></msub>.*?<msub><mi>t</mi><mi>h</mi></msub>.*?<msub><mi>b</mi><mi>b</mi></msub>', 'STRICTLY FORBIDDEN: "mathbb" spelled via repeated single-letter <msub> chains (m_a t_h b_b)'),
        # Generic pattern: 3+ consecutive <msub> with single letters
        (r'(?:<msub><mi>[a-z]</mi><mi>[a-z]</mi></msub>\s*){3,}', 'STRICTLY FORBIDDEN: repeated single-letter subscripts forming words'),
    ]
    
    for pattern, violation in repeated_subscript_words:
        if re.search(pattern, mathml, re.IGNORECASE):
            violations.append(violation)
    
    # Check for msub chains spelling specific words (STRICTLY FORBIDDEN)
    msub_chain_patterns = [
        (r'<msub><mi>l</mi><mi>e</mi>', 'STRICTLY FORBIDDEN: word "left" spelled with <msub> (l_e)'),
        (r'<msub><mi>r</mi><mi>i</mi>', 'STRICTLY FORBIDDEN: word "right" spelled with <msub> (r_i)'),
        (r'<msub><mi>s</mi><mi>u</mi>', 'STRICTLY FORBIDDEN: word "sum" spelled with <msub> (s_u)'),
        (r'<msub><mi>f</mi><mi>r</mi>', 'STRICTLY FORBIDDEN: word "frac" spelled with <msub> (f_r)'),
        (r'<msub><mi>m</mi><mi>a</mi>', 'STRICTLY FORBIDDEN: word "math" spelled with <msub> (m_a)'),
        (r'<msub><mi>e</mi><mi>q</mi><mi>u</mi><mi>i</mi><mi>v</mi>', 'STRICTLY FORBIDDEN: "equiv" spelled via letters in <msub>'),
        (r'<msub><mi>m</mi><mi>a</mi><mi>t</mi><mi>h</mi><mi>b</mi>', 'STRICTLY FORBIDDEN: "mathbb" spelled via letters in <msub>'),
    ]
    
    for pattern, violation in msub_chain_patterns:
        if re.search(pattern, mathml, re.IGNORECASE):
            violations.append(violation)
    
    # Check for "equiv", "sum", "mathbb" spelled via letters (not in msub, but as separate <mi> tags)
    letter_spelling_patterns = [
        (r'<mi>e</mi><mi>q</mi><mi>u</mi><mi>i</mi><mi>v</mi>', 'INVALID: "equiv" spelled via letters'),
        (r'<mi>s</mi><mi>u</mi><mi>m</mi>', 'INVALID: "sum" spelled via letters'),
        (r'<mi>m</mi><mi>a</mi><mi>t</mi><mi>h</mi><mi>b</mi>', 'INVALID: "mathbb" spelled via letters'),
    ]
    
    for pattern, violation in letter_spelling_patterns:
        if re.search(pattern, mathml, re.IGNORECASE):
            violations.append(violation)
    
    # Rule 2: STRICTLY FORBIDDEN - NEVER encode operators as <mi> (MANDATORY)
    # ALL operators must be <mo> (e.g., = + ‚àë ‚àà)
    # Check for operators incorrectly represented as <mi>
    operator_as_identifier = [
        (r'<mi>\s*[=+\-√ó√∑¬±‚àì‚â§‚â•‚â†‚â°‚âà‚àà‚àâ‚äÇ‚äÉ‚à™‚à©]', 'STRICTLY FORBIDDEN: operator incorrectly in <mi> tag - ALL operators must be <mo>'),
        (r'<mi>\s*[‚àë‚àè‚à´‚àÇ‚àá‚àû‚àö]', 'STRICTLY FORBIDDEN: math operator incorrectly in <mi> tag - ALL operators must be <mo>'),
        (r'<mi>\s*[=]', 'STRICTLY FORBIDDEN: = operator in <mi> tag - must be <mo>=</mo>'),
        (r'<mi>\s*[+]', 'STRICTLY FORBIDDEN: + operator in <mi> tag - must be <mo>+</mo>'),
        (r'<mi>\s*[‚àë]', 'STRICTLY FORBIDDEN: ‚àë operator in <mi> tag - must be <mo>&#x2211;</mo>'),
        (r'<mi>\s*[‚àà]', 'STRICTLY FORBIDDEN: ‚àà operator in <mi> tag - must be <mo>&#x2208;</mo>'),
        (r'<mi>\s*[‚â°]', 'STRICTLY FORBIDDEN: ‚â° operator in <mi> tag - must be <mo>&#x2261;</mo>'),
    ]
    
    for pattern, violation in operator_as_identifier:
        if re.search(pattern, mathml):
            violations.append(violation)
    
    # Check for human-readable words embedded in MathML
    human_readable_words = [
        (r'<mtext>\s*(left|right|sum|frac|equiv|mathbb|long)\s*</mtext>', 'INVALID: human-readable word in <mtext>'),
        (r'<mi>\s*(left|right|sum|frac|equiv|mathbb|long)\s*</mi>', 'INVALID: human-readable word in <mi>'),
    ]
    
    for pattern, violation in human_readable_words:
        if re.search(pattern, mathml, re.IGNORECASE):
            violations.append(violation)
    
    # Rule 3: Summations MUST use <munderover> or <munder>, not <msub> (MANDATORY)
    # Check if sum is incorrectly represented
    if '&#x2211;' in mathml or '‚àë' in mathml or '&#x02211;' in mathml or '\\sum' in mathml:
        # Sum exists, check if it's properly structured
        # REJECT if sum uses <msub> instead of <munder> or <munderover>
        if '<msub><mo>' in mathml and ('&#x2211;' in mathml or '‚àë' in mathml):
            # Check if it's a sum with limits (should use <munderover>)
            sum_with_limits = re.search(r'<msub><mo>.*?(?:&#x2211;|‚àë).*?</mo>', mathml)
            if sum_with_limits:
                # Check if limits are properly structured
                if '<munderover>' not in mathml and '<munder>' not in mathml:
                    violations.append('INVALID: Summation MUST use <munderover> or <munder>, not <msub>')
        
        # Also check for sum spelled as letters in <msub>
        if re.search(r'<msub><mi>s</mi><mi>u</mi>', mathml, re.IGNORECASE):
            violations.append('INVALID: Summation spelled as letters in <msub> (must use <mo>&#x2211;</mo> with <munder>)')
    
    # Rule 4: Sets MUST use mathvariant="double-struck" for ‚Ñ§, ‚Ñù, etc. (MANDATORY)
    # Blackboard symbols MUST be Unicode (‚Ñ§) or mathvariant="double-struck"
    # Check if ‚Ñ§ is incorrectly represented
    if 'Z' in mathml or '\\mathbb{Z}' in mathml or 'mathbb{Z}' in mathml:
        # Check if it's correctly represented
        has_double_struck = 'mathvariant="double-struck"' in mathml or '&#x02124;' in mathml or '‚Ñ§' in mathml
        # Check if it's part of a corrupted pattern (fake mathbb)
        if re.search(r'<mi>m</mi><mi>a</mi><mi>t</mi><mi>h</mi>.*<mi>b</mi>.*<mi>Z</mi>', mathml, re.IGNORECASE):
            violations.append('INVALID: ‚Ñ§ incorrectly represented as "math b Z" (fake mathbb - must use Unicode ‚Ñ§ or mathvariant="double-struck")')
        elif 'Z' in mathml and not has_double_struck:
            # Check if it's in a context where it should be double-struck
            if re.search(r'\\mathbb\{Z\}|mathbb.*Z|Z.*mathbb', mathml, re.IGNORECASE):
                violations.append('INVALID: Sets MUST use mathvariant="double-struck" for ‚Ñ§ (not plain Z)')
    
    # Check for ‚Ñù (real numbers) - must use mathvariant="double-struck"
    if 'R' in mathml or '\\mathbb{R}' in mathml or 'mathbb{R}' in mathml:
        has_double_struck_r = 'mathvariant="double-struck"' in mathml or '&#x0211D;' in mathml or '‚Ñù' in mathml
        if 'R' in mathml and not has_double_struck_r:
            if re.search(r'\\mathbb\{R\}|mathbb.*R|R.*mathbb', mathml, re.IGNORECASE):
                violations.append('INVALID: Sets MUST use mathvariant="double-struck" for ‚Ñù (not plain R)')
    
    # Check for ‚àà (element of) - must be <mo>&#x2208;</mo> or Unicode
    if 'in' in mathml.lower() or '\\in' in mathml:
        has_element_of = '&#x2208;' in mathml or '‚àà' in mathml or '<mo>&#x2208;</mo>' in mathml
        if not has_element_of and re.search(r'<mi>\s*in\s*</mi>', mathml, re.IGNORECASE):
            violations.append('INVALID: ‚àà (element of) must use <mo>&#x2208;</mo>, not <mi>in</mi>')
    
    # Check for ‚àë (summation) - must be <mo>&#x2211;</mo> or Unicode
    if 'sum' in mathml.lower() or '\\sum' in mathml:
        has_summation = '&#x2211;' in mathml or '‚àë' in mathml or '<mo>&#x2211;</mo>' in mathml
        if not has_summation and re.search(r'<mi>\s*sum\s*</mi>', mathml, re.IGNORECASE):
            violations.append('INVALID: ‚àë (summation) must use <mo>&#x2211;</mo>, not <mi>sum</mi>')
    
    # Rule 5: MathML must be W3C compliant
    # Check for proper namespace
    if 'xmlns=' not in mathml and 'xmlns:' not in mathml:
        violations.append('MathML missing namespace (not W3C compliant)')
    
    # Check for balanced tags
    tag_pairs = [
        ('<msub>', '</msub>'),
        ('<msup>', '</msup>'),
        ('<mrow>', '</mrow>'),
        ('<munderover>', '</munderover>'),
        ('<munder>', '</munder>'),
    ]
    
    for open_tag, close_tag in tag_pairs:
        open_count = mathml.count(open_tag)
        close_count = mathml.count(close_tag)
        if open_count != close_count:
            violations.append(f'unbalanced {open_tag}/{close_tag} (not W3C compliant)')
    
    # Check for <mtext> containing equations (should not happen)
    # Match actual math tags inside <mtext> content (between <mtext> and </mtext>)
    # This checks if <mtext> contains any math structure tags, which is invalid
    # Pattern: <mtext>...<math_tag>...</mtext> (math tag must be between opening and closing mtext)
    if re.search(r'<mtext[^>]*>.*?<(?:msub|msup|mfrac|munder|mover|munderover|msubsup|mroot|mtable|mtr|mtd|mrow|mi|mo|mn)', mathml, re.DOTALL):
        # Verify the math tag is actually inside mtext by checking it comes before </mtext>
        # Find all mtext blocks and check their content
        mtext_blocks = re.finditer(r'<mtext[^>]*>(.*?)</mtext>', mathml, re.DOTALL)
        for match in mtext_blocks:
            content = match.group(1)
            # Check if this mtext content contains any math structure tags
            if re.search(r'<(?:msub|msup|mfrac|munder|mover|munderover|msubsup|mroot|mtable|mtr|mtd|mrow|mi|mo|mn)', content):
                violations.append('<mtext> contains math structure (should not)')
                break
    
    # GATEKEEPER: Check for <mtext> containing LaTeX commands (CORRUPTED)
    if re.search(r'<mtext>.*\\[a-zA-Z]+\{', mathml):
        violations.append('GATEKEEPER VIOLATION: <mtext> contains LaTeX commands (corrupted MathML)')
    
    # GATEKEEPER: Check for JavaScript error patterns (CORRUPTED)
    if '[object Object]' in mathml:
        violations.append('GATEKEEPER VIOLATION: JavaScript error pattern "[object Object]" detected (corrupted MathML)')
    
    # GATEKEEPER: Check for <mtext> containing array/begin environments (CORRUPTED)
    if re.search(r'<mtext>.*\\begin\{array\}', mathml):
        violations.append('GATEKEEPER VIOLATION: <mtext> contains LaTeX array environment (corrupted MathML)')
    
    return len(violations) == 0, violations


def validate_semantic_operators(mathml: str) -> Tuple[bool, List[str]]:
    """
    Legacy function - redirects to validate_mathml_strict.
    """
    return validate_mathml_strict(mathml)


def is_llm_generated_mathml(mathml: str) -> Tuple[bool, List[str]]:
    """
    GATEKEEPER RULE: Detect if MathML was generated by an LLM.
    
    LLM-generated MathML often has telltale signs:
    - Overly verbose structure
    - Inconsistent formatting
    - Comments or explanations embedded
    - Non-standard patterns that don't match deterministic converters
    
    Returns: (is_llm_generated, list_of_indicators)
    """
    if not mathml:
        return False, []
    
    indicators = []
    
    # Check for LLM-generated patterns
    # 1. Comments or explanations in MathML (LLMs sometimes add these)
    if '<!--' in mathml or '<!--' in mathml.lower():
        indicators.append('LLM INDICATOR: Comments found in MathML (LLMs may add explanations)')
    
    # 2. Overly verbose structure (LLMs tend to be more verbose)
    # Check for excessive nesting that's unusual for deterministic converters
    if mathml.count('<mrow>') > 50:  # Deterministic converters are usually more efficient
        indicators.append('LLM INDICATOR: Excessive <mrow> nesting (unusual for deterministic converters)')
    
    # 3. Inconsistent spacing/formatting (LLMs may have inconsistent whitespace)
    # Check for unusual whitespace patterns
    if re.search(r'<mi>\s{3,}</mi>', mathml) or re.search(r'<mo>\s{3,}</mo>', mathml):
        indicators.append('LLM INDICATOR: Unusual whitespace patterns (inconsistent formatting)')
    
    # 4. Non-standard attribute patterns (LLMs may add unnecessary attributes)
    # Deterministic converters are usually consistent
    if mathml.count('xml:space') > 0:  # Rarely used by deterministic converters
        indicators.append('LLM INDICATOR: Non-standard xml:space attributes')
    
    # 5. Check if MathML structure suggests manual construction vs deterministic
    # Deterministic converters from latex2mathml have predictable patterns
    # LLM-generated MathML may have unusual combinations
    
    return len(indicators) > 0, indicators


def validate_operators_in_mathml(mathml: str) -> Tuple[bool, List[str]]:
    """
    GATEKEEPER RULE: Validate that operators are correctly represented as <mo>, not <mi>.
    
    Returns: (is_valid, list_of_violations)
    """
    if not mathml:
        return False, ['Empty MathML']
    
    violations = []
    
    # Common operators that MUST be <mo>, not <mi>
    operator_patterns = [
        (r'<mi>\s*=\s*</mi>', 'GATEKEEPER VIOLATION: = operator in <mi> - must be <mo>=</mo>'),
        (r'<mi>\s*\+\s*</mi>', 'GATEKEEPER VIOLATION: + operator in <mi> - must be <mo>+</mo>'),
        (r'<mi>\s*-\s*</mi>', 'GATEKEEPER VIOLATION: - operator in <mi> - must be <mo>-</mo>'),
        (r'<mi>\s*√ó\s*</mi>', 'GATEKEEPER VIOLATION: √ó operator in <mi> - must be <mo>√ó</mo>'),
        (r'<mi>\s*√∑\s*</mi>', 'GATEKEEPER VIOLATION: √∑ operator in <mi> - must be <mo>√∑</mo>'),
        (r'<mi>\s*‚â§\s*</mi>', 'GATEKEEPER VIOLATION: ‚â§ operator in <mi> - must be <mo>‚â§</mo>'),
        (r'<mi>\s*‚â•\s*</mi>', 'GATEKEEPER VIOLATION: ‚â• operator in <mi> - must be <mo>‚â•</mo>'),
        (r'<mi>\s*‚â†\s*</mi>', 'GATEKEEPER VIOLATION: ‚â† operator in <mi> - must be <mo>‚â†</mo>'),
        (r'<mi>\s*‚â°\s*</mi>', 'GATEKEEPER VIOLATION: ‚â° operator in <mi> - must be <mo>‚â°</mo>'),
        (r'<mi>\s*‚àà\s*</mi>', 'GATEKEEPER VIOLATION: ‚àà operator in <mi> - must be <mo>‚àà</mo>'),
        (r'<mi>\s*‚àë\s*</mi>', 'GATEKEEPER VIOLATION: ‚àë operator in <mi> - must be <mo>‚àë</mo>'),
        (r'<mi>\s*‚àè\s*</mi>', 'GATEKEEPER VIOLATION: ‚àè operator in <mi> - must be <mo>‚àè</mo>'),
        (r'<mi>\s*‚à´\s*</mi>', 'GATEKEEPER VIOLATION: ‚à´ operator in <mi> - must be <mo>‚à´</mo>'),
    ]
    
    for pattern, violation in operator_patterns:
        if re.search(pattern, mathml):
            violations.append(violation)
    
    return len(violations) == 0, violations


# ============================================================================
# PRE-OPENAI REGEX CORRUPTION CHECKER (CRITICAL)
# ============================================================================

def has_spelling_hack(latex: str) -> Tuple[bool, List[str]]:
    """
    REQUIRED: Regex Guards for LaTeX spelling hacks.
    
    Detects OCR spelling abuse patterns:
    - l_{{o}}n_{{g}} (with braces)
    - \\s_{{u}} (command with subscript)
    - e_q_u_i_v (repeated subscripts)
    - l_o n_g r_i g_h t_a r_r o_w (long sequences)
    
    Returns: (has_hack, list_of_patterns)
    """
    if not latex:
        return False, []
    
    found = []
    
    # SPELLING_HACKS patterns (REQUIRED)
    # BUT: Be careful not to flag valid LaTeX like P_{s_{1},d_{1}} (nested subscripts are valid)
    SPELLING_HACKS = [
        # Pattern: 3+ consecutive letter subscripts (e.g., l_{o}n_{g} - spelling a word)
        # BUT: Exclude valid nested subscripts like s_{1},d_{1} (comma-separated)
        (r'(?:[a-zA-Z]_\{[a-zA-Z]\}){3,}(?![,}])', 'CORRUPTED: spelling hack - repeated letter subscripts with braces (e.g., l_{o}n_{g})'),
        # Pattern: Command with single-letter subscript (e.g., \s_{u} - should be \sum)
        (r'\\[a-zA-Z]\s*_\s*\{[a-zA-Z]\}(?!\s*[a-zA-Z_0-9])', r'CORRUPTED: spelling hack - command with single-letter subscript (e.g., \\\\s_{u})'),
        # Pattern: Repeated single-letter subscripts without braces (e.g., e_q_u_i_v)
        (r'(?:_[a-zA-Z]){3,}', 'CORRUPTED: spelling hack - repeated single-letter subscripts (e.g., e_q_u_i_v)'),
        # Pattern: Letter subscript chains (e.g., l_{o}n_{g})
        # BUT: Exclude valid patterns like s_{1},d_{1} (comma-separated subscripts)
        (r'[a-zA-Z]\s*_\s*\{[a-zA-Z]\}\s*[a-zA-Z]\s*_\s*\{[a-zA-Z]\}(?![,}])', 'CORRUPTED: spelling hack - letter subscript chains (e.g., l_{o}n_{g})'),
    ]
    
    for pattern, description in SPELLING_HACKS:
        if re.search(pattern, latex, re.IGNORECASE):
            found.append(description)
    
    # Specific word patterns (long, right, arrow, sum, equiv, mathbb, in, forall)
    word_patterns = [
        (r'l\s*_\s*\{?\s*o\s*\}?\s*n\s*_\s*\{?\s*g\s*\}?', 'CORRUPTED: "long" spelled via subscripts (l_o n_g)'),
        (r'r\s*_\s*\{?\s*i\s*\}?\s*g\s*_\s*\{?\s*h\s*\}?\s*t\s*_\s*\{?\s*a\s*\}?', 'CORRUPTED: "right" spelled via subscripts (r_i g_h t_a)'),
        (r'a\s*_\s*\{?\s*r\s*\}?\s*r\s*_\s*\{?\s*o\s*\}?\s*w', 'CORRUPTED: "arrow" spelled via subscripts (a_r r_o w)'),
        (r'\bs\s*_\s*\{?\s*u\s*\}?\s*m\b', 'CORRUPTED: "sum" spelled via subscripts (s_u m)'),
        (r's\s*_\s*\{?\s*u\s*\}?\s+m\b', 'CORRUPTED: "sum" spelled via subscripts (s_u m with space)'),
        (r's\s*_\s*u\s*_\s*m\b', 'CORRUPTED: "sum" spelled via subscripts (s_u_m)'),
        (r'\bs\s*_\s*u\s*_\s*m\b', 'CORRUPTED: "sum" spelled via subscripts (s_u_m)'),
        (r'e\s*_\s*\{?\s*q\s*\}?\s*u\s*_\s*\{?\s*i\s*\}?\s*v', 'CORRUPTED: "equiv" spelled via subscripts (e_q u_i v)'),
        (r'm\s*_\s*\{?\s*a\s*\}?\s*t\s*_\s*\{?\s*h\s*\}?\s*b\s*_\s*\{?\s*b\s*\}?', 'CORRUPTED: "mathbb" spelled via subscripts (m_a t_h b_b)'),
        (r'i\s*_\s*\{?\s*n\s*\}?\s*(?!\s*\{)', 'CORRUPTED: "in" spelled via subscripts (i_n)'),
        (r'f\s*_\s*\{?\s*o\s*\}?\s*r\s*_\s*\{?\s*a\s*\}?\s*l\s*_\s*\{?\s*l\s*\}?', 'CORRUPTED: "forall" spelled via subscripts (f_o r_a l_l)'),
    ]
    
    for pattern, description in word_patterns:
        if re.search(pattern, latex, re.IGNORECASE):
            found.append(description)
    
    return len(found) > 0, found


def pre_openai_regex_corruption_checker(latex: str) -> Tuple[bool, List[str]]:
    """
    PRE-OPENAI REGEX CORRUPTION CHECKER (CRITICAL)
    
    Run BEFORE OpenAI is called to detect split-letter LaTeX (spelling hacks).
    
    Detects:
    - e_q u_i v (split equiv)
    - s_u m (split sum)
    - m_i n (split min)
    - l_o n_g (split long)
    - Alphabet-as-operator abuse
    
    Returns: (is_corrupted, list_of_patterns)
    """
    if not latex:
        return False, []
    
    found = []
    
    # üî¥ Detect split-letter LaTeX (spelling hacks)
    # Pattern: (\\[a-zA-Z]+)?(_\{?[a-zA-Z]\}?){3,}
    # Catches: e_q u_i v, s_u m, m_i n, l_o n_g
    split_letter_pattern = r'(?:\\[a-zA-Z]+)?(_\{?[a-zA-Z]\}?){3,}'
    if re.search(split_letter_pattern, latex):
        found.append('CORRUPTED: split-letter LaTeX detected (spelling hack)')
    
    # Specific split patterns
    split_patterns = [
        (r'e\s*_\s*\{?\s*q\s*\}?\s*u\s*_\s*\{?\s*i\s*\}?\s*v', 'CORRUPTED: e_q u_i v (split equiv)'),
        (r's\s*_\s*\{?\s*u\s*\}?\s*m\s*(?!\s*\{)', 'CORRUPTED: s_u m (split sum)'),
        (r'm\s*_\s*\{?\s*i\s*\}?\s*n\s*(?!\s*\{)', 'CORRUPTED: m_i n (split min)'),
        (r'l\s*_\s*\{?\s*o\s*\}?\s*n\s*_\s*\{?\s*g\s*\}?', 'CORRUPTED: l_o n_g (split long)'),
        (r'r\s*_\s*\{?\s*i\s*\}?\s*g\s*_\s*\{?\s*h\s*\}?\s*t\s*_\s*\{?\s*a\s*\}?', 'CORRUPTED: r_i g_h t_a (split right)'),
    ]
    
    for pattern, description in split_patterns:
        if re.search(pattern, latex, re.IGNORECASE):
            found.append(description)
    
    # Detect alphabet-as-operator abuse
    # Pattern: \\(equiv|sum|min|max|log|sin|cos)\b
    # If these appear broken into letters, flag corruption
    operator_abuse_patterns = [
        (r'(?<!\\)\bequiv\b(?!\s*\{)', 'CORRUPTED: equiv written as text (should be \\equiv)'),
        (r'(?<!\\)\bsum\b(?!\s*\{)', 'CORRUPTED: sum written as text (should be \\sum)'),
        (r'(?<!\\)\bmin\b(?!\s*\{)', 'CORRUPTED: min written as text (should be \\min)'),
        (r'(?<!\\)\bmax\b(?!\s*\{)', 'CORRUPTED: max written as text (should be \\max)'),
    ]
    
    for pattern, description in operator_abuse_patterns:
        if re.search(pattern, latex, re.IGNORECASE):
            found.append(description)
    
    return len(found) > 0, found


# ============================================================================
# AST-LEVEL CHECKER (REQUIRED)
# ============================================================================

def validate_latex_ast_rules(latex: str) -> Tuple[bool, List[str]]:
    """
    AST-LEVEL CHECKER for LaTeX (REQUIRED).
    
    LaTeX AST Rules - Reject if:
    - Operator nodes represented as identifiers
    - Subscripts contain >1 alphabetic token
    - Command tokens fragmented into letters
    
    Returns: (is_valid, list_of_violations)
    """
    if not latex:
        return True, []
    
    violations = []
    
    # Check: Operator nodes represented as identifiers
    # Pattern: operators written as plain text (not commands)
    operator_as_identifier = [
        (r'(?<!\\)\b(equiv|sum|min|max|log|sin|cos|in|notin)\b(?!\s*\{)', 'AST VIOLATION: operator represented as identifier'),
    ]
    
    for pattern, violation in operator_as_identifier:
        if re.search(pattern, latex, re.IGNORECASE):
            violations.append(violation)
    
    # Check: Subscripts contain >1 alphabetic token
    # Pattern: _{word} where word is multi-letter (not single identifier)
    multi_letter_subscript = r'_\s*\{([a-zA-Z]{2,})\}'
    matches = re.findall(multi_letter_subscript, latex)
    for match in matches:
        # Allow common math identifiers (but not words)
        if match.lower() not in ['in', 'eq', 'ne', 'le', 'ge']:
            violations.append(f'AST VIOLATION: subscript contains >1 alphabetic token: {match}')
    
    # Check: Command tokens fragmented into letters
    # Pattern: letter-by-letter subscripts that form commands
    fragmented_commands = [
        (r'([a-z])_\{([a-z])\}([a-z])_\{([a-z])\}([a-z])', 'AST VIOLATION: command token fragmented into letters'),
    ]
    
    for pattern, violation in fragmented_commands:
        if re.search(pattern, latex, re.IGNORECASE):
            violations.append(violation)
    
    return len(violations) == 0, violations


def validate_mathml_ast_rules(mathml: str) -> Tuple[bool, List[str]]:
    """
    AST-LEVEL CHECKER for MathML (REQUIRED).
    
    MathML AST Rules - Reject if:
    - <msub> used to encode English words
    - <mi> nodes form known operators sequentially
    - <mo> missing for =, ‚â°, +, ‚àë
    
    Returns: (is_valid, list_of_violations)
    """
    if not mathml or '<math' not in mathml:
        return False, ['Empty or invalid MathML']
    
    violations = []
    
    # Check: <msub> used to encode English words
    # Pattern: <msub><mi>X</mi><mi>Y</mi></msub> where XY forms a word
    msub_word_patterns = [
        (r'<msub><mi>l</mi><mi>e</mi>', 'AST VIOLATION: <msub> encodes English word "le"'),
        (r'<msub><mi>r</mi><mi>i</mi>', 'AST VIOLATION: <msub> encodes English word "ri"'),
        (r'<msub><mi>s</mi><mi>u</mi>', 'AST VIOLATION: <msub> encodes English word "su"'),
        (r'<msub><mi>e</mi><mi>q</mi>', 'AST VIOLATION: <msub> encodes English word "eq"'),
    ]
    
    for pattern, violation in msub_word_patterns:
        if re.search(pattern, mathml, re.IGNORECASE):
            violations.append(violation)
    
    # Check: <mi> nodes form known operators sequentially
    # Pattern: <mi>e</mi><mi>q</mi><mi>u</mi><mi>i</mi><mi>v</mi> (forms "equiv")
    operator_sequences = [
        (r'<mi>e</mi><mi>q</mi><mi>u</mi><mi>i</mi><mi>v</mi>', 'AST VIOLATION: <mi> nodes form operator "equiv"'),
        (r'<mi>s</mi><mi>u</mi><mi>m</mi>', 'AST VIOLATION: <mi> nodes form operator "sum"'),
        (r'<mi>m</mi><mi>i</mi><mi>n</mi>', 'AST VIOLATION: <mi> nodes form operator "min"'),
        (r'<mi>m</mi><mi>a</mi><mi>x</mi>', 'AST VIOLATION: <mi> nodes form operator "max"'),
    ]
    
    for pattern, violation in operator_sequences:
        if re.search(pattern, mathml, re.IGNORECASE):
            violations.append(violation)
    
    # Check: <mo> missing for =, ‚â°, +, ‚àë
    # Pattern: <mi>=</mi> or <mi>+</mi> or <mi>‚â°</mi> or <mi>‚àë</mi>
    missing_mo_patterns = [
        (r'<mi>\s*[=]', 'AST VIOLATION: <mo> missing for = (found in <mi>)'),
        (r'<mi>\s*[+]', 'AST VIOLATION: <mo> missing for + (found in <mi>)'),
        (r'<mi>\s*[‚â°]', 'AST VIOLATION: <mo> missing for ‚â° (found in <mi>)'),
        (r'<mi>\s*[‚àë]', 'AST VIOLATION: <mo> missing for ‚àë (found in <mi>)'),
    ]
    
    for pattern, violation in missing_mo_patterns:
        if re.search(pattern, mathml):
            violations.append(violation)
    
    return len(violations) == 0, violations


# ============================================================================
# STEP 2: LaTeX VALIDATION (NO AI)
# ============================================================================


def pre_openai_regex_corruption_checker(latex: str) -> Tuple[bool, List[str]]:
    """
    PRE-OPENAI REGEX CORRUPTION CHECKER (CRITICAL)
    
    Run BEFORE OpenAI is called to detect split-letter LaTeX (spelling hacks).
    
    Detects:
    - e_q u_i v (split equiv)
    - s_u m (split sum)
    - m_i n (split min)
    - l_o n_g (split long)
    - Alphabet-as-operator abuse
    
    Returns: (is_corrupted, list_of_patterns)
    """
    if not latex:
        return False, []
    
    found = []
    
    # üî¥ Detect split-letter LaTeX (spelling hacks)
    # Pattern: (\\[a-zA-Z]+)?(_\{?[a-zA-Z]\}?){3,}
    # Catches: e_q u_i v, s_u m, m_i n, l_o n_g
    split_letter_pattern = r'(?:\\[a-zA-Z]+)?(_\{?[a-zA-Z]\}?){3,}'
    if re.search(split_letter_pattern, latex):
        found.append('CORRUPTED: split-letter LaTeX detected (spelling hack)')
    
    # Specific split patterns
    split_patterns = [
        (r'e\s*_\s*\{?\s*q\s*\}?\s*u\s*_\s*\{?\s*i\s*\}?\s*v', 'CORRUPTED: e_q u_i v (split equiv)'),
        (r's\s*_\s*\{?\s*u\s*\}?\s*m\s*(?!\s*\{)', 'CORRUPTED: s_u m (split sum)'),
        (r'm\s*_\s*\{?\s*i\s*\}?\s*n\s*(?!\s*\{)', 'CORRUPTED: m_i n (split min)'),
        (r'l\s*_\s*\{?\s*o\s*\}?\s*n\s*_\s*\{?\s*g\s*\}?', 'CORRUPTED: l_o n_g (split long)'),
        (r'r\s*_\s*\{?\s*i\s*\}?\s*g\s*_\s*\{?\s*h\s*\}?\s*t\s*_\s*\{?\s*a\s*\}?', 'CORRUPTED: r_i g_h t_a (split right)'),
    ]
    
    for pattern, description in split_patterns:
        if re.search(pattern, latex, re.IGNORECASE):
            found.append(description)
    
    # Detect alphabet-as-operator abuse
    # Pattern: \\(equiv|sum|min|max|log|sin|cos)\b
    # If these appear broken into letters, flag corruption
    operator_abuse_patterns = [
        (r'(?<!\\)\bequiv\b(?!\s*\{)', 'CORRUPTED: equiv written as text (should be \\equiv)'),
        (r'(?<!\\)\bsum\b(?!\s*\{)', 'CORRUPTED: sum written as text (should be \\sum)'),
        (r'(?<!\\)\bmin\b(?!\s*\{)', 'CORRUPTED: min written as text (should be \\min)'),
        (r'(?<!\\)\bmax\b(?!\s*\{)', 'CORRUPTED: max written as text (should be \\max)'),
    ]
    
    for pattern, description in operator_abuse_patterns:
        if re.search(pattern, latex, re.IGNORECASE):
            found.append(description)
    
    return len(found) > 0, found


def detect_latex_corruption(latex: str) -> Tuple[bool, List[str]]:
    """
    MANDATORY: Detect ALL LaTeX corruption patterns (ZERO tolerance).
    
    Detects:
    - Split commands: e_q u_i v, l_o n_g r_i g_h t_a, s_u m, m_a t_h b_b
    - Alphabet-as-subscript abuse: subscript spelling words, nested msub equivalents
    - Broken operators: = rendered as text, sum written as s u m, Z written as mathbb via characters
    - Invalid structures: operators represented as variables, missing bounds on summations
    
    Returns: (is_corrupted, list_of_patterns_found)
    """
    if not latex:
        return False, []
    
    found = []
    
    # Pattern 1: Split commands (MANDATORY detection)
    # e_q u_i v, l_o n_g r_i g_h t_a, s_u m, m_a t_h b_b
    split_command_patterns = [
        (r'e\s*_\s*\{?\s*q\s*\}?\s*u\s*_\s*\{?\s*i\s*\}?\s*v', 'split command: e_q u_i v (should be \\equiv)'),
        (r'l\s*_\s*\{?\s*o\s*\}?\s*n\s*_\s*\{?\s*g\s*\}?\s*r\s*_\s*\{?\s*i\s*\}?\s*g\s*_\s*\{?\s*h\s*\}?\s*t\s*_\s*\{?\s*a\s*\}?', 'split command: l_o n_g r_i g_h t_a'),
        (r's\s*_\s*\{?\s*u\s*\}?\s*m\s*(?!\s*\{)', 'split command: s_u m (should be \\sum)'),
        (r'm\s*_\s*\{?\s*a\s*\}?\s*t\s*_\s*\{?\s*h\s*\}?\s*b\s*_\s*\{?\s*b\s*\}?', 'split command: m_a t_h b_b (should be \\mathbb)'),
        # Pattern: letter-by-letter subscripting (split command)
        # BUT: Exclude valid patterns like s_{1},d_{1} (comma-separated subscripts)
        (r'([a-z])_\{([a-z])\}([a-z])_\{([a-z])\}([a-z])(?![,}])', 'letter-by-letter subscripting (split command)'),
        # Pattern: shredded LaTeX command (e.g., \l_{e}f_{t} instead of \left)
        (r'\\[a-z]_\{[a-z]\}[a-z]_\{[a-z]\}[a-z](?!\s*[a-zA-Z_0-9,}])', 'shredded LaTeX command'),
    ]
    
    for pattern, description in split_command_patterns:
        if re.search(pattern, latex, re.IGNORECASE):
            found.append(description)
    
    # Pattern 2: Alphabet-as-subscript abuse (MANDATORY detection)
    # \subscript spelling words, nested msub equivalents
    # BUT: Exclude valid patterns like s_{1},d_{1} (comma-separated subscripts)
    alphabet_abuse_patterns = [
        # Pattern: 3+ consecutive letter subscripts (spelling a word)
        # BUT: Exclude if followed by comma (valid comma-separated subscripts)
        (r'([a-z])_\{([a-z])\}([a-z])_\{([a-z])\}([a-z])_\{([a-z])\}(?![,}])', 'alphabet-as-subscript abuse (repeated letter subscripts)'),
        # Pattern: Repeated letter subscripts (but exclude comma-separated)
        (r'_\{[a-z]\}[a-z]_\{[a-z]\}[a-z]_\{[a-z]\}(?![,}])', 'repeated letter subscripts (alphabet abuse)'),
        # Nested subscript patterns that spell words
        (r'([a-z])_\{([a-z])_\{([a-z])\}([a-z])_\{([a-z])\}\}', 'nested subscript spelling word'),
    ]
    
    for pattern, description in alphabet_abuse_patterns:
        if re.search(pattern, latex, re.IGNORECASE):
            found.append(description)
    
    # Pattern 3: Broken operators (MANDATORY detection)
    # = rendered as text, sum written as s u m, Z written as mathbb via characters
    broken_operator_patterns = [
        (r'(?<!\\)\b(left|right|sum|frac|mathbb|equiv|in)\b(?!\s*\{)', 'broken operator (missing backslash)'),
        (r'\\[a-z]\s+[a-z]\s+[a-z]', 'spaced command (broken operator: e.g., \\ s u m)'),
        (r'\\[a-z]_\{[a-z]\}\s+[a-z]', 'broken command with subscript'),
        # Sum written as text (not command)
        (r'(?<!\\)\bsum\b(?!\s*\{)', 'broken operator: sum written as text (should be \\sum)'),
        # Z written as mathbb via characters
        (r'm\s*a\s*t\s*h\s*b\s*Z', 'broken operator: Z written as mathbb via characters'),
    ]
    
    for pattern, description in broken_operator_patterns:
        if re.search(pattern, latex, re.IGNORECASE):
            found.append(description)
    
    # Pattern 4: Invalid structures (MANDATORY detection)
    # Operators represented as variables, missing bounds on summations
    invalid_structure_patterns = [
        (r'\\sum\s*\{[^}]*\}\s*(?!\^|_)', 'invalid structure: sum missing bounds'),
        (r'\\sum\s*(?!\{|_|\^)', 'invalid structure: sum missing subscript/superscript'),
        # Operators represented as variables (e.g., = as variable)
        # BUT: Don't flag if = is followed by valid LaTeX command or math expression
        # This pattern is too broad and causes false positives
        # Only flag if = appears in suspicious context (e.g., as subscript)
        (r'_\s*\{[^}]*=\s*[^}]*\}', 'potential: = in subscript (suspicious)'),
    ]
    
    for pattern, description in invalid_structure_patterns:
        if re.search(pattern, latex, re.IGNORECASE):
            found.append(description)
    
    return len(found) > 0, found


def detect_shredded_commands(latex: str) -> Tuple[bool, List[str]]:
    """
    Legacy function - redirects to detect_latex_corruption.
    """
    return detect_latex_corruption(latex)


def detect_mathml_split_words(mathml: str) -> Tuple[bool, List[str]]:
    """
    Detect split words in MathML <mi> tags (e.g., <mi>m</mi><mi>a</mi><mi>t</mi><mi>h</mi>).
    
    Also detects split operators and fake subscripts.
    
    Returns: (is_corrupted, list_of_patterns_found)
    """
    if not mathml or '<mi>' not in mathml:
        return False, []
    
    found = []
    
    # Pattern: 4+ consecutive single-character <mi> tags (letter-splitting)
    pattern = r'(?:<mi>\s*[a-zA-Z]\s*</mi>\s*){4,}'
    matches = re.findall(pattern, mathml)
    if matches:
        found.append('consecutive single-character <mi> tags (letter-splitting)')
    
    # Pattern: Split operators in <msub> (e.g., <msub><mi>l</mi> for "left")
    split_operator_patterns = [
        (r'<msub><mi>l</mi>', 'split "left" or "long" operator'),
        (r'<msub><mi>s</mi>', 'split "sum" operator'),
        (r'<msub><mi>f</mi>', 'split "frac" operator'),
        (r'<msub><mi>r</mi>', 'split "right" operator'),
    ]
    for pattern, description in split_operator_patterns:
        if re.search(pattern, mathml, re.IGNORECASE):
            found.append(description)
    
    # Pattern: <mi> with length > 1 but no mathvariant (suspicious)
    # This catches cases like <mi>math</mi> that should be <mi mathvariant="normal">math</mi>
    # or split into proper structure
    pattern2 = r'<mi>([a-z]{2,})</mi>'
    matches2 = re.findall(pattern2, mathml)
    if matches2:
        # Check if these look like split words (common math words)
        math_words = ['math', 'left', 'right', 'frac', 'sum', 'prod', 'int', 'partial', 'long']
        for match in matches2:
            if match.lower() in math_words:
                found.append(f'split word in <mi>: {match}')
    
    # Pattern: Fake subscripts (plain text words in <msub>)
    fake_subscript_pattern = r'<msub><mi>([a-z]{2,})</mi>'
    fake_matches = re.findall(fake_subscript_pattern, mathml, re.IGNORECASE)
    invalid_words = ['left', 'right', 'sum', 'frac', 'math', 'long', 'text', 'error']
    for match in fake_matches:
        if match.lower() in invalid_words:
            found.append(f'fake subscript (plain text word): {match}')
    
    return len(found) > 0, found


def detect_malformed_mathml_tags(mathml: str) -> Tuple[bool, List[str]]:
    """
    Detect malformed MathML tags (unbalanced, invalid structure).
    
    Also checks for operator correctness and semantic issues.
    
    Returns: (is_corrupted, list_of_issues)
    """
    if not mathml or '<math' not in mathml:
        return False, []
    
    issues = []
    
    # Check for unbalanced tags
    tag_pairs = [
        ('<msub>', '</msub>'),
        ('<msup>', '</msup>'),
        ('<mrow>', '</mrow>'),
        ('<mfrac>', '</mfrac>'),
        ('<munder>', '</munder>'),
        ('<mover>', '</mover>'),
    ]
    
    for open_tag, close_tag in tag_pairs:
        open_count = mathml.count(open_tag)
        close_count = mathml.count(close_tag)
        if open_count != close_count:
            issues.append(f'unbalanced {open_tag}/{close_tag} ({open_count} open, {close_count} close)')
    
    # Check for <mtext> containing LaTeX commands (corrupted)
    if re.search(r'<mtext>.*\\[a-zA-Z]+\{.*\}</mtext>', mathml):
        issues.append('<mtext> contains LaTeX commands')
    
    # Check for incorrect operator representation
    # Sum should be <mo>&#x2211;</mo> or <mo>‚àë</mo>, NOT split letters
    if r'\sum' not in mathml:  # Only check if LaTeX not present
        if '<mo>&#x2211;</mo>' not in mathml and '<mo>‚àë</mo>' not in mathml:
            # Check if sum is split
            if re.search(r'<mi>s</mi><mi>u</mi><mi>m</mi>', mathml, re.IGNORECASE):
                issues.append('sum operator split into letters')
    
    # Check for incorrect equivalence representation
    # \equiv should be <mo>&#x2261;</mo> or <mo>‚â°</mo>
    if '<mo>&#x2261;</mo>' not in mathml and '<mo>‚â°</mo>' not in mathml and '<mo>&#x02261;</mo>' not in mathml:
        if re.search(r'<mi>e</mi><mi>q</mi><mi>u</mi><mi>i</mi><mi>v</mi>', mathml, re.IGNORECASE):
            issues.append('equiv operator split into letters')
    
    # Check for incorrect \in representation
    # \in should be <mo>&#x2208;</mo> or <mo>‚àà</mo>
    if '<mo>&#x2208;</mo>' not in mathml and '<mo>‚àà</mo>' not in mathml and '<mo>&#x02208;</mo>' not in mathml:
        if re.search(r'<mi>i</mi><mi>n</mi>', mathml, re.IGNORECASE):
            issues.append('in operator split into letters')
    
        # Check for incorrect \\mathbb{Z} representation
        # Should be <mi mathvariant="double-struck">Z</mi>, NOT "math b Z"
        if 'mathvariant="double-struck"' not in mathml and '&#x02124;' not in mathml:
            if re.search(r'math\s+b\s+Z', mathml, re.IGNORECASE) or re.search(r'<mi>m</mi><mi>a</mi><mi>t</mi><mi>h</mi>.*<mi>b</mi>', mathml, re.IGNORECASE):
                issues.append('mathbb{Z} corrupted as "math b Z" (should be <mi mathvariant="double-struck">Z</mi>)')
    
    return len(issues) > 0, issues


def calculate_corruption_score(latex: str, mathml: str) -> float:
    """
    Calculate corruption score (0.0 to 1.0).
    
    Returns score > 0.3 if corruption is significant enough to warrant AI intervention.
    """
    score = 0.0
    
    # LaTeX corruption checks
    if latex:
        is_shredded, patterns = detect_shredded_commands(latex)
        if is_shredded:
            score += 0.4  # Shredded commands are serious
        if len(patterns) > 1:
            score += 0.1 * (len(patterns) - 1)  # Multiple patterns increase score
    
    # MathML corruption checks
    if mathml:
        is_split, split_patterns = detect_mathml_split_words(mathml)
        if is_split:
            score += 0.3  # Split words are serious
        if len(split_patterns) > 1:
            score += 0.1 * (len(split_patterns) - 1)
        
        is_malformed, malformed_issues = detect_malformed_mathml_tags(mathml)
        if is_malformed:
            score += 0.3  # Malformed tags are serious
        if len(malformed_issues) > 1:
            score += 0.1 * (len(malformed_issues) - 1)
    
    return min(1.0, score)


# ============================================================================
# STEP 2: LaTeX VALIDATION (NO AI)
# ============================================================================

def is_semantically_clean_latex(latex: str) -> bool:
    """
    RULE 1 ‚Äî NEVER SEND CLEAN LATEX TO OPENAI
    
    Check if LaTeX is semantically clean (no corrupted patterns).
    If clean, skip OpenAI completely.
    
    Returns True if LaTeX is clean, False if corrupted.
    """
    if not latex or not latex.strip():
        return False
    
    # Check for obvious corruption patterns
    forbidden_patterns = [
        r"[a-zA-Z]_\{[a-zA-Z]\}\s*[a-zA-Z]_\{[a-zA-Z]\}",  # chained subscripts
        r"s_\{u\}\s*m",       # s_u m
        r"s\s*_\s*\{?\s*u\s*\}?\s*m\b",  # s_u m (flexible)
        r"f_\{r\}\s*a_\{c\}", # f_r a_c
        r"f\s*_\s*\{?\s*r\s*\}?\s*a\s*_\s*\{?\s*c\s*\}?",  # f_r a_c (flexible)
        r"l_\{e\}\s*f_\{t\}", # l_e f_t
        r"l\s*_\s*\{?\s*e\s*\}?\s*f\s*_\s*\{?\s*t\s*\}?",  # l_e f_t (flexible)
        r"r_\{i\}\s*g_\{h\}\s*t", # r_i g_h t
        r"r\s*_\s*\{?\s*i\s*\}?\s*g\s*_\s*\{?\s*h\s*\}?\s*t",  # r_i g_h t (flexible)
        r"e_\{q\}\s*u_\{i\}\s*v",  # e_q u_i v
        r"e\s*_\s*\{?\s*q\s*\}?\s*u\s*_\s*\{?\s*i\s*\}?\s*v",  # e_q u_i v (flexible)
        r"m_\{a\}\s*t_\{h\}\s*b_\{b\}",  # m_a t_h b_b
        r"m\s*_\s*\{?\s*a\s*\}?\s*t\s*_\s*\{?\s*h\s*\}?\s*b\s*_\s*\{?\s*b\s*\}?",  # m_a t_h b_b (flexible)
        r"l_\{e\}\s*q",  # l_e q
        r"l\s*_\s*\{?\s*e\s*\}?\s*q",  # l_e q (flexible)
    ]
    
    # Check for obvious corruption patterns first
    if any(re.search(p, latex, re.IGNORECASE) for p in forbidden_patterns):
        return False
    
    # Check for garbled/nonsensical patterns (common OCR errors)
    # Pattern: Repeated single characters with subscripts (e.g., c_x c_u v_e c)
    if re.search(r'[a-z]_\{[a-z]\}\s*[a-z]_\{[a-z]\}\s*[a-z]_\{[a-z]\}', latex, re.IGNORECASE):
        return False
    
    # Pattern: Malformed commands (e.g., \mathrm{cxcuvec} - "cxcuvec" is not a valid word)
    # Check for commands with suspiciously long or garbled arguments
    if re.search(r'\\mathrm\{[a-z]{6,}[^}]*\}', latex, re.IGNORECASE):
        # Check if it looks like garbled text (not common math words)
        suspicious_words = ['cxcuvec', 'cxcu', 'cxc', 'cx', 'cuvec', 'vecu']
        for word in suspicious_words:
            if word in latex.lower():
                return False
    
    # Pattern: Incomplete or truncated LaTeX (ends with incomplete commands)
    if re.search(r'\\[a-z]+\s*$', latex) or re.search(r'\{[^}]*$', latex):
        return False
    
    # Pattern: Excessive nested braces or malformed structure
    brace_count = latex.count('{') - latex.count('}')
    if abs(brace_count) > 5:  # More than 5 unmatched braces suggests corruption
        return False
    
    return True


def validate_latex_syntax(latex: str) -> Tuple[bool, List[str]]:
    """
    Validate LaTeX syntax WITHOUT using AI.
    
    Checks:
    - Balanced {{}}
    - Valid commands (\\sum, \\equiv, \\mathbb)
    - Valid subscripts/superscripts
    
    Returns: (is_valid, list_of_errors)
    """
    if not latex or not latex.strip():
        return False, ['Empty LaTeX string']
    
    errors = []
    
    # Check balanced braces
    open_braces = latex.count('{')
    close_braces = latex.count('}')
    if open_braces != close_braces:
        errors.append(f'Unbalanced braces: {open_braces} open, {close_braces} close')
    
    # Check for valid LaTeX commands (basic check - not exhaustive)
    # Look for backslash followed by letters (valid command pattern)
    invalid_command_pattern = r'\\(?![a-zA-Z]+\{?|[^a-zA-Z])'
    if re.search(invalid_command_pattern, latex):
        errors.append('Invalid LaTeX command pattern detected')
    
    # Check for valid subscripts/superscripts
    # Pattern: _{...} or ^{...} should have balanced braces
    subscript_pattern = r'_\s*\{[^}]*'
    superscript_pattern = r'\^\s*\{[^}]*'
    for match in re.finditer(subscript_pattern, latex):
        # Check if this subscript has a closing brace
        start = match.end()
        remaining = latex[start:]
        if not remaining.startswith('}'):
            errors.append(f'Unclosed subscript at position {match.start()}')
    
    for match in re.finditer(superscript_pattern, latex):
        start = match.end()
        remaining = latex[start:]
        if not remaining.startswith('}'):
            errors.append(f'Unclosed superscript at position {match.start()}')
    
    return len(errors) == 0, errors


# ============================================================================
# STRICT PIPELINE RESULT
# ============================================================================

class StrictPipelineResult(TypedDict, total=False):
    """Result from strict pipeline."""
    source_type: Literal["latex", "mathml", "plain", "empty"]
    clean_latex: str
    mathml: str
    is_valid: bool
    corruption_score: float
    validation_errors: List[str]
    corruption_detected: List[str]
    stage_failed: Optional[str]  # Which stage caused failure
    used_ai: bool
    log: List[str]


# ============================================================================
# STRICT PIPELINE
# ============================================================================

class StrictMathpixPipeline:
    """
    Strict Mathpix-style pipeline with ZERO math token corruption.
    
    Rules:
    1. NEVER split LaTeX macros into characters
    2. NEVER rewrite math symbols unless syntax is invalid
    3. AI is ONLY used as last resort for malformed MathML
    """
    
    def __init__(self):
        self.log: List[str] = []
        self._image_to_latex = None  # Lazy initialization
    
    def _get_image_to_latex(self):
        """Lazy initialization of ImageToLatex."""
        if self._image_to_latex is None:
            try:
                from services.ocr.image_to_latex import ImageToLatex
                self._image_to_latex = ImageToLatex()
            except Exception as exc:
                logger.warning(f"Could not initialize ImageToLatex: {exc}")
                self._image_to_latex = False  # Mark as unavailable
        return self._image_to_latex if self._image_to_latex else None
    
    def process_image(self, image_path: str | Path) -> StrictPipelineResult:
        """
        MANDATORY Pipeline: Process image/PDF through complete pipeline.
        
        STEP 1: Image/PDF ‚Üí Pix2Tex or Nougat ‚Üí LaTeX
        Then continues with process_latex() for remaining steps.
        """
        from pathlib import Path
        
        self.log = []
        self.log.append(f"STEP 1: Processing image/PDF: {image_path}")
        
        # STEP 1: Image/PDF ‚Üí LaTeX (Pix2Tex or Nougat)
        image_to_latex = self._get_image_to_latex()
        if not image_to_latex:
            return StrictPipelineResult(
                source_type="empty",
                clean_latex="",
                mathml="",
                human_readable="",
                is_valid=False,
                corruption_score=1.0,
                validation_errors=["ImageToLatex not available"],
                corruption_detected=[],
                stage_failed="ocr_initialization",
                used_ai=False,
                log=self.log
            )
        
        try:
            self.log.append("STEP 1: Performing OCR (Pix2Tex or Tesseract)")
            raw_latex = image_to_latex.image_to_latex(image_path)
            self.log.append(f"STEP 1 PASSED: OCR produced LaTeX (length: {len(raw_latex)})")
            self.log.append(f"STEP 1: Raw LaTeX preview: {raw_latex[:100]}")
            
            # Continue with LaTeX processing
            return self.process_latex(raw_latex)
            
        except Exception as exc:
            self.log.append(f"STEP 1 FAILED: OCR failed: {exc}")
            return StrictPipelineResult(
                source_type="empty",
                clean_latex="",
                mathml="",
                human_readable="",
                is_valid=False,
                corruption_score=1.0,
                validation_errors=[f"OCR failed: {exc}"],
                corruption_detected=[],
                stage_failed="ocr",
                used_ai=False,
                log=self.log
            )
    
    def _normalize_latex_to_valid_commands(self, latex: str) -> str:
        """
        STEP 1: Normalize LaTeX into valid math commands.
        
        Replace spelled tokens with canonical operators BEFORE conversion.
        
        üö´ ZERO-TOLERANCE: Never preserve broken tokens.
        ‚úÖ SEMANTIC PRIORITY: Reconstruct from meaning, not OCR.
        
        Patterns handled:
        - f_r a_c ‚Üí \\frac
        - s_u_m ‚Üí \\sum
        - l_e_f_t ‚Üí \\left
        - r_i_g_h_t ‚Üí \\right
        - e_q_u_i_v ‚Üí \\equiv
        - m_a_t_h_b_b ‚Üí \\mathbb
        - b_f ‚Üí \\mathbf
        """
        """
        STEP 1: Normalize LaTeX into valid math commands.
        
        Replace spelled tokens with canonical operators BEFORE conversion.
        
        Fixes:
        - e_q u_i v ‚Üí \\equiv
        - s_u m ‚Üí \\sum
        - m_i n ‚Üí \\min
        - l_o n_g ‚Üí \\long
        - m_a t_h b_b ‚Üí \\mathbb
        - etc.
        
        This is MANDATORY - ensures semantic correctness.
        """
        if not latex:
            return latex
        
        normalized = latex
        
        # STEP 1: Replace spelled tokens with canonical operators
        # Common operators that are often spelled
        operator_replacements = [
            # Equivalence
            (r'e\s*_\s*\{?\s*q\s*\}?\s*u\s*_\s*\{?\s*i\s*\}?\s*v', r'\\equiv'),
            (r'e\s*_\s*\{?\s*q\s*\}?\s*u\s*_\s*\{?\s*i\s*\}?\s*v\s*a\s*l', r'\\equiv'),
            # Summation
            (r's\s*_\s*\{?\s*u\s*\}?\s*m\s*(?!\s*\{)', r'\\sum'),
            # Minimum/Maximum
            (r'm\s*_\s*\{?\s*i\s*\}?\s*n\s*(?!\s*\{)', r'\\min'),
            (r'm\s*_\s*\{?\s*a\s*\}?\s*x\s*(?!\s*\{)', r'\\max'),
            # Fractions (f_r a_c ‚Üí \\frac) - MUST come first
            (r'f\s*_\s*\{?\s*r\s*\}?\s+a\s*_\s*\{?\s*c\s*\}?\b', r'\\frac'),  # f_r a_c (with space)
            (r'f\s*_\s*\{?\s*r\s*\}?\s*a\s*_\s*\{?\s*c\s*\}?\b', r'\\frac'),  # f_r a_c (no space)
            # Left/Right
            (r'l\s*_\s*\{?\s*e\s*\}?\s*f\s*_\s*\{?\s*t\s*\}?', r'\\left'),
            (r'r\s*_\s*\{?\s*i\s*\}?\s*g\s*_\s*\{?\s*h\s*\}?\s*t', r'\\right'),
            # Long
            (r'l\s*_\s*\{?\s*o\s*\}?\s*n\s*_\s*\{?\s*g\s*\}?', r'\\long'),
            # Mathbb
            (r'm\s*_\s*\{?\s*a\s*\}?\s*t\s*_\s*\{?\s*h\s*\}?\s*b\s*_\s*\{?\s*b\s*\}?', r'\\mathbb'),
            # Not equal
            (r'n\s*_\s*\{?\s*e\s*\}?\s*q', r'\\neq'),
            # Dots
            (r'l\s*_\s*\{?\s*d\s*\}?\s*o\s*_\s*\{?\s*t\s*\}?\s*s', r'\\ldots'),
            # Bigcup
            (r'b\s*_\s*\{?\s*i\s*\}?\s*g\s*_\s*\{?\s*c\s*\}?\s*u\s*_\s*\{?\s*p\s*\}?', r'\\bigcup'),
            # In
            (r'i\s*_\s*\{?\s*n\s*\}?\s*(?!\s*\{)', r'\\in'),
        ]
        
        for pattern, replacement in operator_replacements:
            normalized = re.sub(pattern, replacement, normalized, flags=re.IGNORECASE)
        
        return normalized
    
    def _repair_broken_operators(self, latex: str) -> str:
        """
        Legacy function - redirects to _normalize_latex_to_valid_commands.
        """
        return self._normalize_latex_to_valid_commands(latex)
    
    def process_mathml(self, mathml: str) -> StrictPipelineResult:
        """
        MANDATORY Pipeline: Process MathML input with ZERO tolerance for corruption.
        
        If MathML is corrupted (e.g., operators spelled via subscripts), reconstruct from semantics.
        
        MANDATORY STEPS:
        1. Detect corruption in MathML
        2. If corrupted ‚Üí Extract semantic meaning ‚Üí Reconstruct clean LaTeX
        3. Convert clean LaTeX ‚Üí Clean MathML
        4. Validate final MathML
        """
        self.log = []
        self.log.append("=" * 80)
        self.log.append("MANDATORY PIPELINE: Processing MathML input")
        self.log.append("=" * 80)
        
        if not mathml or not mathml.strip():
            return StrictPipelineResult(
                source_type="empty",
                clean_latex="",
                mathml="",
                human_readable="",
                is_valid=False,
                corruption_score=1.0,
                validation_errors=["Empty MathML input"],
                corruption_detected=[],
                stage_failed="mathml_input",
                used_ai=False,
                log=self.log
            )
        
        # STEP 1: GATEKEEPER - Detect corruption and invalid patterns in MathML
        self.log.append("STEP 1: GATEKEEPER - Detecting corruption and invalid patterns in MathML input")
        is_corrupted = is_corrupted_mathml(mathml)
        has_spelled_words, spelled_violations = mathml_has_spelled_words(mathml)
        is_ast_valid, ast_violations = validate_mathml_ast_rules(mathml)
        is_mathml_valid, mathml_violations = validate_mathml_strict(mathml)
        
        # GATEKEEPER: Check for LLM-generated MathML (REJECT)
        is_llm_generated, llm_indicators = is_llm_generated_mathml(mathml)
        if is_llm_generated:
            self.log.append("=" * 80)
            self.log.append("üõë GATEKEEPER: LLM-GENERATED MathML DETECTED - REJECTING")
            self.log.append(f"LLM Indicators: {llm_indicators[:3]}")
            self.log.append("RULE: MathML must come from deterministic LaTeX‚ÜíMathML compiler")
            self.log.append("INVALID MATH ‚Äî OUTPUT SUPPRESSED")
            self.log.append("=" * 80)
            return StrictPipelineResult(
                source_type="mathml",
                clean_latex="",
                mathml="",
                human_readable="",
                is_valid=False,
                corruption_score=1.0,
                validation_errors=["LLM-generated MathML detected - REJECTED"],
                corruption_detected=llm_indicators,
                stage_failed="gatekeeper_llm_detection",
                used_ai=False,
                log=self.log
            )
        
        # GATEKEEPER: Validate operators are <mo>, not <mi> (REJECT if violated)
        operators_valid, operator_violations = validate_operators_in_mathml(mathml)
        if not operators_valid:
            self.log.append("=" * 80)
            self.log.append("üõë GATEKEEPER: OPERATOR VIOLATIONS DETECTED - REJECTING")
            self.log.append(f"Operator Violations: {operator_violations[:3]}")
            self.log.append("RULE: Operators MUST be <mo>, not <mi>")
            self.log.append("INVALID MATH ‚Äî OUTPUT SUPPRESSED")
            self.log.append("=" * 80)
            return StrictPipelineResult(
                source_type="mathml",
                clean_latex="",
                mathml="",
                human_readable="",
                is_valid=False,
                corruption_score=1.0,
                validation_errors=["Operators incorrectly in <mi> instead of <mo> - REJECTED"],
                corruption_detected=operator_violations,
                stage_failed="gatekeeper_operator_validation",
                used_ai=False,
                log=self.log
            )
        
        corruption_detected = []
        if is_corrupted:
            corruption_detected.append('CORRUPTED: MathML contains corruption patterns')
        if has_spelled_words:
            corruption_detected.extend(spelled_violations)
        if not is_ast_valid:
            corruption_detected.extend(ast_violations)
        if not is_mathml_valid:
            corruption_detected.extend(mathml_violations)
        
        used_ai = False
        clean_latex = ""
        
        # STEP 2: If corrupted, reconstruct from semantics
        if is_corrupted or has_spelled_words or not is_ast_valid or not is_mathml_valid:
            self.log.append("=" * 80)
            self.log.append("üö® CORRUPTION DETECTED in MathML input")
            self.log.append("=" * 80)
            self.log.append("STEP 2: MANDATORY OpenAI SEMANTIC RECONSTRUCTION")
            self.log.append("GATEKEEPER: DO NOT preserve corrupted structure - reconstruct from semantics")
            
            # Extract LaTeX from corrupted MathML or reconstruct semantically
            # Use OpenAI to reconstruct clean LaTeX from corrupted MathML
            try:
                from services.ocr.openai_mathml_converter import OpenAIMathMLConverter
                from core.config import settings
                
                api_key = getattr(settings, 'openai_api_key', None)
                if not api_key:
                    self.log.append("ERROR: OpenAI API key required for MathML reconstruction but not found")
                    return StrictPipelineResult(
                        source_type="mathml",
                        clean_latex="",
                        mathml=mathml,
                        human_readable="",
                        is_valid=False,
                        corruption_score=1.0,
                        validation_errors=["OpenAI API key not found"],
                        corruption_detected=corruption_detected,
                        stage_failed="openai_mathml_reconstruction",
                        used_ai=False,
                        log=self.log
                    )
                
                self.log.append("MANDATORY: Initializing OpenAI for MathML ‚Üí LaTeX reconstruction")
                converter = OpenAIMathMLConverter(
                    api_key=api_key,
                    model=getattr(settings, 'openai_model', 'gpt-4o-mini')
                )
                
                # Build context for semantic reconstruction
                context = f"""You are a MathOCR semantic reconstruction engine.

Input is CORRUPTED MathML where operators are spelled using subscripts:
- <msub><mi>e</mi><mi>q</mi></msub><msub><mi>u</mi><mi>i</mi></msub><msub><mi>v</mi>... (should be <mo>‚â°</mo>)
- <msub><mi>m</mi><mrow>...<mi>a</mi><mi>t</mi><mi>h</mi><msub><mi>b</mi><mi>b</mi></msub><mi>Z</mi>... (should be <mi mathvariant="double-struck">Z</mi>)

üö´ MANDATORY RULES:
- NEVER preserve broken MathML structure
- NEVER output LaTeX that spells words via subscripts
- ALWAYS reconstruct correct mathematical operators

CORRUPTION DETECTED:
{chr(10).join(f"- {pattern}" for pattern in corruption_detected[:15])}

‚úÖ RECONSTRUCTION RULES:
- Extract semantic meaning from corrupted MathML
- Reconstruct clean LaTeX with proper operators:
  ‚Ä¢ e_q u_i v ‚Üí \\equiv
  ‚Ä¢ m_a t_h b_b Z ‚Üí \\mathbb{{Z}}
  ‚Ä¢ s_u m ‚Üí \\sum
  ‚Ä¢ Missing = operators should be added if semantically correct

CRITICAL EXAMPLE:
If MathML has: <msub><mi>Y</mi><mi>j</mi></msub>[t]<msub><mi>e</mi><mi>q</mi></msub>...<msub><mi>m</mi>...<mi>Z</mi>...
Then LaTeX should be: Y_j[t] = \\sum_{{i \\in \\mathbb{{Z}}(j)}} ...

üß† SEMANTIC RECONSTRUCTION PRIORITY:
- RECONSTRUCT FROM SEMANTICS, not fix tokens
- Discard corrupted MathML structure and rebuild from mathematical meaning
- If visual MathML conflicts with math meaning, ALWAYS choose mathematical meaning

OUTPUT FORMAT (MANDATORY - JSON ONLY):
{{
  "latex": "<clean semantic latex>",
  "confidence": 0.90
}}

CRITICAL RULES:
- Output MUST be valid JSON that can be parsed with json.loads()
- NO markdown code blocks (```json ... ```)
- NO explanations or prose
- NO step-by-step descriptions
- ONLY the JSON object itself

Example of CORRECT output:
{{"latex": "\\mathbf{{D}}=\\left\\{{(D_{{1}},...,D_{{K}})\\in\\mathbb{{R}}_{{+}}^{{K}}:\\forall w_{{1}},...,w_{{K}}\\in\\mathbb{{R}}_{{+}},\\sum_{{i=1}}^{{K}}w_{{i}}D_{{i}}\\le\\lim_{{P\\to\\infty}}\\left(\\sup_{{(R_{{1}},...,R_{{K}})\\in\\mathcal{{C}}(P)}}\\frac{{w_{{1}}R_{{1}}+...+w_{{K}}R_{{K}}}}{{\\frac{{1}}{{2}}\\log P}}\\right)\\right\\}}", "confidence": 0.95}}

Example of INCORRECT output (DO NOT DO THIS):
To reconstruct the corrupted MathML and produce clean LaTeX and MathML, we will follow the outlined steps.
### Step 1: Reconstruct the Equation
From the corrupted MathML, we can identify the intended...
```json
{{"latex": "...", "confidence": 0.95}}
```"""
                
                self.log.append("MANDATORY: Calling OpenAI to reconstruct LaTeX from corrupted MathML")
                # Try convert_corrupted_mathml first, fallback to convert_latex_to_mathml_strict
                if hasattr(converter, 'convert_corrupted_mathml'):
                    result = converter.convert_corrupted_mathml(
                        mathml,
                        target_format="latex",
                        include_latex=True
                    )
                else:
                    # Fallback: use convert_latex_to_mathml_strict with MathML as context
                    # Extract any LaTeX-like content from MathML first
                    extracted_latex = self._extract_latex_from_mathml(mathml)
                    if extracted_latex:
                        result = converter.convert_latex_to_mathml_strict(
                            extracted_latex,
                            context=context
                        )
                    else:
                        # Last resort: send MathML as string and ask for LaTeX
                        result = converter.convert_latex_to_mathml_strict(
                            mathml,
                            context=context
                        )
                
                # Parse result - convert_corrupted_mathml returns dict with "latex" and/or "mathml"
                clean_latex = result.get("latex", "") or result.get("clean_latex", "")
                clean_mathml_result = result.get("mathml", "") or result.get("clean_mathml", "")
                confidence = result.get("confidence", 0.0)
                
                self.log.append(f"STEP 2: OpenAI result keys: {list(result.keys())}")
                self.log.append(f"STEP 2: clean_latex length: {len(clean_latex) if clean_latex else 0}")
                self.log.append(f"STEP 2: clean_mathml_result length: {len(clean_mathml_result) if clean_mathml_result else 0}")
                self.log.append(f"STEP 2: confidence: {confidence}")
                
                # If clean_latex is a string that looks like JSON, parse it
                if isinstance(clean_latex, str) and clean_latex.strip().startswith('{'):
                    try:
                        import json
                        parsed = json.loads(clean_latex)
                        clean_latex = parsed.get("latex", "")
                        confidence = parsed.get("confidence", confidence)
                        self.log.append(f"MANDATORY: Parsed JSON response from OpenAI (confidence: {confidence:.2f})")
                    except (json.JSONDecodeError, AttributeError):
                        self.log.append("MANDATORY: OpenAI response is not valid JSON, using as-is")
                
                # CRITICAL: Strip typographic spacing from reconstructed LaTeX (MANDATORY)
                # MathML is SEMANTIC, never typographic - spacing commands must be removed
                if clean_latex:
                    clean_latex_before_strip = clean_latex
                    clean_latex = self._strip_typographic_spacing(clean_latex)
                    if clean_latex != clean_latex_before_strip:
                        self.log.append("STEP 2.5: Stripped typographic spacing from reconstructed LaTeX")
                
                if clean_latex and confidence > 0.5:
                    self.log.append(f"STEP 2 PASSED: OpenAI reconstructed clean LaTeX (confidence: {confidence:.2f})")
                    used_ai = True
                elif clean_mathml_result and confidence > 0.5:
                    # If we got MathML but not LaTeX, try to extract LaTeX from it
                    self.log.append(f"STEP 2: OpenAI returned MathML, extracting LaTeX (confidence: {confidence:.2f})")
                    clean_latex = self._extract_latex_from_mathml(clean_mathml_result)
                    if clean_latex:
                        self.log.append(f"STEP 2: Extracted LaTeX from MathML: {clean_latex[:50]}")
                        used_ai = True
                    else:
                        self.log.append("STEP 2 WARNING: Could not extract LaTeX from returned MathML")
                else:
                    self.log.append(f"STEP 2 FAILED: OpenAI reconstruction did not produce clean LaTeX (confidence: {confidence:.2f})")
                    self.log.append(f"STEP 2: Result dict: {result}")
                    # Try to extract LaTeX from original MathML using basic parsing
                    # This is a fallback - not ideal but better than nothing
                    clean_latex = self._extract_latex_from_mathml(mathml)
                    if clean_latex:
                        self.log.append(f"STEP 2 FALLBACK: Extracted LaTeX from MathML: {clean_latex[:50]}")
                    else:
                        self.log.append("STEP 2 FAILED: Could not extract LaTeX from MathML")
                        return StrictPipelineResult(
                            source_type="mathml",
                            clean_latex="",
                            mathml="",
                            human_readable="",
                            is_valid=False,
                            corruption_score=1.0,
                            validation_errors=["Could not reconstruct LaTeX from corrupted MathML"],
                            corruption_detected=corruption_detected,
                            stage_failed="mathml_reconstruction",
                            used_ai=used_ai,
                            log=self.log
                        )
            except ValueError as exc:
                # JSON-only violation - log and reject
                self.log.append(f"STEP 2 FAILED: OpenAI violated JSON-only requirement: {exc}")
                self.log.append("CRITICAL: OpenAI returned markdown/prose instead of JSON")
                return StrictPipelineResult(
                    source_type="mathml",
                    clean_latex="",
                    mathml="",
                    human_readable="",
                    is_valid=False,
                    corruption_score=1.0,
                    validation_errors=[f"OpenAI violated JSON-only requirement: {exc}"],
                    corruption_detected=corruption_detected,
                    stage_failed="mathml_reconstruction_json_violation",
                    used_ai=used_ai,
                    log=self.log
                )
            except Exception as exc:
                self.log.append(f"STEP 2 FAILED: MathML reconstruction failed: {exc}")
                return StrictPipelineResult(
                    source_type="mathml",
                    clean_latex="",
                    mathml="",
                    human_readable="",
                    is_valid=False,
                    corruption_score=1.0,
                    validation_errors=[f"MathML reconstruction failed: {exc}"],
                    corruption_detected=corruption_detected,
                    stage_failed="mathml_reconstruction",
                    used_ai=used_ai,
                    log=self.log
                )
        else:
            self.log.append("STEP 1 PASSED: MathML is clean, extracting LaTeX")
            # MathML is clean, extract LaTeX
            clean_latex = self._extract_latex_from_mathml(mathml)
            if not clean_latex:
                self.log.append("STEP 1 WARNING: Could not extract LaTeX from clean MathML")
        
        # STEP 3: Process clean LaTeX through the normal pipeline
        if clean_latex:
            self.log.append("STEP 3: Processing reconstructed LaTeX through pipeline")
            latex_result = self.process_latex(clean_latex)
            # Merge results
            return StrictPipelineResult(
                source_type="mathml",
                clean_latex=latex_result.get("clean_latex", clean_latex),
                mathml=latex_result.get("mathml", ""),
                human_readable=latex_result.get("human_readable", ""),
                is_valid=latex_result.get("is_valid", False),
                corruption_score=latex_result.get("corruption_score", 0.0),
                validation_errors=latex_result.get("validation_errors", []),
                corruption_detected=latex_result.get("corruption_detected", corruption_detected),
                stage_failed=latex_result.get("stage_failed"),
                used_ai=latex_result.get("used_ai", used_ai),
                log=self.log + latex_result.get("log", [])
            )
        else:
            return StrictPipelineResult(
                source_type="mathml",
                clean_latex="",
                mathml="",
                human_readable="",
                is_valid=False,
                corruption_score=1.0,
                validation_errors=["Could not extract or reconstruct LaTeX from MathML"],
                corruption_detected=corruption_detected,
                stage_failed="mathml_processing",
                used_ai=used_ai,
                log=self.log
            )
    
    def _extract_latex_from_mathml(self, mathml: str) -> str:
        """
        Extract LaTeX from MathML (basic extraction).
        
        This is a fallback method - OpenAI reconstruction is preferred.
        """
        if not mathml:
            return ""
        
        # Try to extract text content and convert to LaTeX
        # This is a simple fallback - not comprehensive
        import re
        
        # Remove MathML tags and extract content
        text = re.sub(r'<[^>]+>', ' ', mathml)
        text = re.sub(r'\s+', ' ', text).strip()
        
        # Basic conversion attempts
        # This is very basic - OpenAI is much better
        return text
    
    def process_latex(self, latex: str) -> StrictPipelineResult:
        """
        MANDATORY Pipeline: Process LaTeX with ZERO tolerance for corruption.
        
        Pipeline Flow (matches user diagram):
        1. Normalize LaTeX (strip $ delimiters)
        2. Regex + AST corruption detector
           ‚îú‚îÄ‚îÄ CLEAN ‚Üí ‚õî NO OPENAI ‚Üí LaTeX ‚Üí AST ‚Üí MathML (DETERMINISTIC)
           ‚îî‚îÄ‚îÄ CORRUPTED ‚Üí OpenAI (SEMANTIC LaTeX REPAIR ONLY) ‚Üí Clean LaTeX ‚Üí LaTeX ‚Üí AST ‚Üí MathML
        3. Validate LaTeX syntax
        4. Convert CLEAN LaTeX ‚Üí MathML (deterministic latex2mathml)
        5. Validate MathML (zero tolerance)
        """
        self.log = []
        self.log.append(f"STEP 1: Received LaTeX input (length: {len(latex)})")
        
        # ============================================================================
        # STEP 1: NORMALIZE LaTeX (strip $ delimiters)
        # ============================================================================
        clean_latex = latex.strip()
        if clean_latex.startswith("$") and clean_latex.endswith("$"):
            clean_latex = clean_latex[1:-1].strip()
            self.log.append(f"STEP 1.5: Stripped $ delimiters from LaTeX")
        
        # ============================================================================
        # STEP 2: REGEX + AST CORRUPTION GATE
        # ============================================================================
        # RULE 1 ‚Äî NEVER SEND CLEAN LATEX TO OPENAI (CHECK FIRST!)
        # ============================================================================
        self.log.append("=" * 80)
        self.log.append("STEP 2: REGEX + AST CORRUPTION GATE (CRITICAL)")
        self.log.append("=" * 80)
        
        # Initialize all variables to avoid UnboundLocalError
        used_ai = False
        corruption_detected = []
        is_corrupted = False
        is_pre_corrupted = False
        has_hack = False
        is_ast_valid = True
        pre_corruption_patterns = []
        hack_patterns = []
        ast_violations = []
        corruption_patterns = []
        
        # RULE 1: Check if LaTeX is semantically clean FIRST
        is_clean = is_semantically_clean_latex(clean_latex)
        
        if is_clean:
            self.log.append("=" * 80)
            self.log.append("‚úÖ RULE 1: LaTeX is semantically clean - SKIPPING all corruption checks and OpenAI")
            self.log.append("=" * 80)
            # Clean LaTeX ‚Üí proceed directly to deterministic LaTeX ‚Üí MathML conversion
            used_ai = False
        else:
            # LaTeX is NOT clean - run corruption detectors
            self.log.append("STEP 2.1: PRE-OPENAI regex corruption checker (CRITICAL)")
            is_pre_corrupted, pre_corruption_patterns = pre_openai_regex_corruption_checker(clean_latex)
            
            self.log.append("STEP 2.2: Spelling hack detection (REQUIRED)")
            has_hack, hack_patterns = has_spelling_hack(clean_latex)
            
            self.log.append("STEP 2.3: AST-level checker for LaTeX")
            is_ast_valid, ast_violations = validate_latex_ast_rules(clean_latex)
            
            self.log.append("STEP 2.4: Full LaTeX corruption detection")
            is_corrupted, corruption_patterns = detect_latex_corruption(clean_latex)
            
            # Collect all corruption patterns
            if is_pre_corrupted:
                corruption_detected.extend(pre_corruption_patterns)
            if has_hack:
                corruption_detected.extend(hack_patterns)
            if not is_ast_valid:
                corruption_detected.extend(ast_violations)
            if is_corrupted:
                corruption_detected.extend(corruption_patterns)
            
            # ============================================================================
            # CORRUPTION GATE: If corruption detected ‚Üí OpenAI semantic repair
            # ============================================================================
            if is_pre_corrupted or has_hack or not is_ast_valid or is_corrupted:
                self.log.append("=" * 80)
                self.log.append("üö® CORRUPTION GATE TRIGGERED - OpenAI semantic repair")
                self.log.append("=" * 80)
                self.log.append("STEP 3: MANDATORY OpenAI SEMANTIC RECONSTRUCTION (LaTeX repair ONLY)")
                self.log.append("GATEKEEPER: DO NOT attempt local fixes - escalating to OpenAI")
                self.log.append("RULE: RECONSTRUCT FROM SEMANTICS, not fix tokens")
                
                all_corruption = corruption_detected if corruption_detected else (pre_corruption_patterns + hack_patterns + ast_violations + corruption_patterns)
                clean_latex = self._mandatory_openai_cleanup(clean_latex, all_corruption)
                used_ai = True

                if not clean_latex or clean_latex == latex:
                    self.log.append("STEP 3 WARNING: OpenAI semantic rewrite did not improve LaTeX")
                    # Check if we have a pre-cleaned version (with truncation fixes) that's different
                    # This happens when OpenAI fails but we fixed truncation issues
                    if clean_latex and clean_latex != latex:
                        self.log.append("STEP 3: Using cleaned LaTeX (with truncation fixes) as fallback")
                        # Continue to MathML conversion with cleaned LaTeX
                    else:
                        self.log.append("STEP 3: Using original LaTeX, will attempt MathML conversion anyway")
                        clean_latex = latex
                    # Continue to MathML conversion - don't reject yet
                else:
                    self.log.append(f"STEP 3 PASSED: OpenAI semantic rewrite restored clean LaTeX (length: {len(clean_latex)})")
                    # Re-validate cleaned LaTeX (but be more lenient - allow minor issues)
                    is_still_corrupted, still_corrupted_patterns = detect_latex_corruption(clean_latex)
                    has_still_hack, still_hack_patterns = has_spelling_hack(clean_latex)
                    
                    # Check if corruption is severe (spelling hacks) vs minor (syntax issues)
                    # Filter out false positives:
                    # - "potential: = rendered as text" is often a false positive (valid = followed by command)
                    # - "letter subscript chains" might match valid patterns like s_{1},d_{1} (comma-separated)
                    filtered_corruption = [p for p in still_corrupted_patterns 
                                        if 'potential:' not in str(p).lower() 
                                        and not ('letter subscript' in str(p).lower() and any(c in str(p) for c in [',', '}']))]
                    filtered_hack = [p for p in still_hack_patterns 
                                    if not any(valid in str(p).lower() for valid in ['s_{1},d_{1}', 'comma-separated', 'valid nested'])]
                    
                    # Check if we have real corruption (not just false positives)
                    has_real_corruption = len(filtered_corruption) > 0 or len(filtered_hack) > 0
                    severe_corruption = (has_still_hack and len(filtered_hack) > 0) or any(
                        'spelling hack' in str(p).lower() and 'potential:' not in str(p).lower() 
                        for p in filtered_corruption
                    )
                    minor_corruption = is_still_corrupted and not severe_corruption and has_real_corruption
                    
                    # If only false positives, treat as no corruption
                    if not has_real_corruption:
                        self.log.append("STEP 3: Validation detected only false positives - treating as clean")
                        # Continue with cleaned LaTeX
                    elif severe_corruption:
                        # Severe corruption (spelling hacks) - try one more OpenAI retry
                        self.log.append(f"WARNING: Severe corruption persists after OpenAI cleanup: {still_corrupted_patterns + still_hack_patterns}")
                        self.log.append("STEP 3.5: Attempting second OpenAI retry for severe corruption")
                        retry_latex = self._mandatory_openai_cleanup(clean_latex, still_corrupted_patterns + still_hack_patterns)
                        
                        if retry_latex and retry_latex != clean_latex:
                            # Check if retry improved it
                            is_retry_corrupted, retry_corrupted_patterns = detect_latex_corruption(retry_latex)
                            has_retry_hack, retry_hack_patterns = has_spelling_hack(retry_latex)
                            
                            if not has_retry_hack and not is_retry_corrupted:
                                self.log.append("STEP 3.5 PASSED: Second OpenAI retry fixed corruption")
                                clean_latex = retry_latex
                            else:
                                self.log.append(f"STEP 3.5 FAILED: Retry still has corruption: {retry_corrupted_patterns + retry_hack_patterns}")
                                self.log.append("üö® FAIL CLOSED: Rejecting output - severe corruption persists after retry")
                                return StrictPipelineResult(
                                    source_type="latex",
                                    clean_latex=clean_latex,
                                    mathml="",
                                    human_readable=clean_latex,
                                    is_valid=False,
                                    corruption_score=1.0,
                                    validation_errors=["Severe corruption persists after OpenAI retry"],
                                    corruption_detected=retry_corrupted_patterns + retry_hack_patterns,
                                    stage_failed="post_openai_retry_validation",
                                    used_ai=True,
                                    log=self.log,
                                )
                        else:
                            self.log.append("STEP 3.5 FAILED: Retry did not improve LaTeX")
                            # Last resort: Apply letter-by-letter fixes directly to clean_latex
                            # SAFETY: if LaTeX is already semantically clean, do NOT mutate it further.
                            if is_semantically_clean_latex(clean_latex):
                                self.log.append("STEP 3.5: Clean LaTeX detected ‚Äî skipping letter-by-letter fallback")
                                self.log.append("üö® FAIL CLOSED: Rejecting output - severe corruption persists")
                                return StrictPipelineResult(
                                    source_type="latex",
                                    clean_latex=clean_latex,
                                    mathml="",
                                    human_readable=clean_latex,
                                    is_valid=False,
                                    corruption_score=1.0,
                                    validation_errors=["Severe corruption persists after OpenAI rewrite"],
                                    corruption_detected=still_corrupted_patterns + still_hack_patterns,
                                    stage_failed="post_openai_validation",
                                    used_ai=True,
                                    log=self.log,
                                )

                            self.log.append("STEP 3.5: Applying final letter-by-letter fixes as last resort")
                            final_fixed_latex = self._apply_letter_by_letter_fixes(clean_latex)
                            
                            if final_fixed_latex != clean_latex:
                                # Re-validate the fixed LaTeX
                                is_final_corrupted, final_corrupted_patterns = detect_latex_corruption(final_fixed_latex)
                                has_final_hack, final_hack_patterns = has_spelling_hack(final_fixed_latex)
                                
                                if not has_final_hack and not is_final_corrupted:
                                    self.log.append("STEP 3.5 PASSED: Final letter-by-letter fixes resolved corruption")
                                    clean_latex = final_fixed_latex
                                    # Continue processing with fixed LaTeX
                                else:
                                    self.log.append(f"STEP 3.5: Final fixes still have corruption: {final_corrupted_patterns + final_hack_patterns}")
                                    self.log.append("üö® FAIL CLOSED: Rejecting output - severe corruption persists")
                                    return StrictPipelineResult(
                                        source_type="latex",
                                        clean_latex=clean_latex,
                                        mathml="",
                                        human_readable=clean_latex,
                                        is_valid=False,
                                        corruption_score=1.0,
                                        validation_errors=["Severe corruption persists after OpenAI rewrite"],
                                        corruption_detected=still_corrupted_patterns + still_hack_patterns,
                                        stage_failed="post_openai_validation",
                                        used_ai=True,
                                        log=self.log,
                                    )
                            else:
                                self.log.append("üö® FAIL CLOSED: Rejecting output - severe corruption persists")
                                return StrictPipelineResult(
                                    source_type="latex",
                                    clean_latex=clean_latex,
                                    mathml="",
                                    human_readable=clean_latex,
                                    is_valid=False,
                                    corruption_score=1.0,
                                    validation_errors=["Severe corruption persists after OpenAI rewrite"],
                                    corruption_detected=still_corrupted_patterns + still_hack_patterns,
                                    stage_failed="post_openai_validation",
                                    used_ai=True,
                                    log=self.log,
                                )
                    elif minor_corruption:
                        # Minor corruption (syntax issues) - log warning but proceed
                        self.log.append(f"WARNING: Minor corruption detected after OpenAI cleanup: {still_corrupted_patterns}")
                        self.log.append("STEP 3: Proceeding with minor corruption (will be validated in syntax check)")
                        # Continue - syntax validation will catch real issues
                    else:
                        # No corruption - perfect!
                        self.log.append("STEP 3: OpenAI cleanup successful - no corruption detected")
            else:
                # No corruption detected - proceed with normalized LaTeX
                self.log.append("STEP 2 PASSED: No corruption detected in LaTeX")
                self.log.append("STEP 2: Proceeding with normalized LaTeX (no OpenAI needed)")
                used_ai = False

        # ============================================================================
        # STEP 4: Validate LaTeX syntax (with automatic brace balancing)
        # ============================================================================
        self.log.append("STEP 4: Validating LaTeX syntax")
        
        # Auto-fix unbalanced braces (common OCR issue)
        # Check for unbalanced braces in all LaTeX, not just arrays
        latex_to_validate = clean_latex
        open_braces = clean_latex.count('{')
        close_braces = clean_latex.count('}')
        if open_braces != close_braces:
            diff = open_braces - close_braces
            # Only auto-balance if difference is small (1-3 braces) to avoid making things worse
            if abs(diff) <= 3:
                is_array = re.search(r'\\begin\{(array|bmatrix|pmatrix|vmatrix|Vmatrix|matrix)', clean_latex, re.IGNORECASE)
                if diff > 0:
                    # Add missing closing braces at the end (before \end if present)
                    if '\\end{' in clean_latex:
                        # Insert before \end
                        end_pos = clean_latex.rfind('\\end{')
                        latex_to_validate = clean_latex[:end_pos] + '}' * diff + clean_latex[end_pos:]
                    else:
                        latex_to_validate = clean_latex + '}' * diff
                    env_type = "array environment" if is_array else "LaTeX"
                    self.log.append(f"STEP 4: Auto-balanced braces for {env_type} (+{diff} closing braces)")
                elif diff < 0:
                    # Add missing opening braces at the start (after \begin if present)
                    begin_match = re.search(r'\\begin\{[^}]+\}', clean_latex)
                    if begin_match:
                        insert_pos = begin_match.end()
                        latex_to_validate = clean_latex[:insert_pos] + '{' * abs(diff) + clean_latex[insert_pos:]
                    else:
                        latex_to_validate = '{' * abs(diff) + clean_latex
                    env_type = "array environment" if is_array else "LaTeX"
                    self.log.append(f"STEP 4: Auto-balanced braces for {env_type} (+{abs(diff)} opening braces)")
            else:
                # Difference is too large, log warning but don't auto-fix
                self.log.append(f"STEP 4: Large brace imbalance detected ({diff} difference), skipping auto-fix")
        
        ok, errs = validate_latex_syntax(latex_to_validate)
        if not ok:
            # If validation still fails, try with original (might be a false positive)
            if latex_to_validate != clean_latex:
                self.log.append("STEP 4: Retrying validation with original LaTeX (brace fix may have caused issues)")
                ok_orig, errs_orig = validate_latex_syntax(clean_latex)
                if ok_orig:
                    ok, errs = ok_orig, errs_orig
                    latex_to_validate = clean_latex
                    self.log.append("STEP 4: Original LaTeX passes validation, using it")
            
            if not ok:
                self.log.append(f"STEP 4 FAILED: LaTeX validation errors: {errs}")
                # If we attempted auto-balancing, be more lenient - try conversion anyway
                # This helps with OCR errors that create minor brace imbalances
                if latex_to_validate != clean_latex:
                    # We attempted to fix braces, so try conversion with the fixed version
                    is_array = re.search(r'\\begin\{(array|bmatrix|pmatrix|vmatrix|Vmatrix|matrix)', clean_latex, re.IGNORECASE)
                    env_type = "array environment" if is_array else "LaTeX"
                    self.log.append(f"STEP 4: {env_type} detected with auto-balanced braces - attempting conversion despite validation errors")
                    # Update clean_latex to use balanced version
                    clean_latex = latex_to_validate
                elif re.search(r'\\begin\{(array|bmatrix|pmatrix|vmatrix|Vmatrix|matrix)', clean_latex, re.IGNORECASE):
                    # Array environment but no auto-balancing was done - still try conversion
                    self.log.append("STEP 4: Array environment detected - attempting conversion despite validation errors")
                else:
                    # No auto-balancing attempted and not an array - return error
                    return StrictPipelineResult(
                        source_type="latex",
                        clean_latex=clean_latex,
                        mathml="",
                        human_readable=clean_latex,
                        is_valid=False,
                        corruption_score=1.0,
                        validation_errors=errs,
                        corruption_detected=corruption_detected,
                        stage_failed="latex_validation",
                        used_ai=used_ai,
                        log=self.log,
                    )
        else:
            # Use balanced version if we fixed it
            if latex_to_validate != clean_latex:
                clean_latex = latex_to_validate
                self.log.append("STEP 4 PASSED: LaTeX validation passed after brace balancing")

        # ============================================================================
        # STEP 4.5: Safe LaTeX Normalization (PRE-MathML, deterministic only)
        # ============================================================================
        # Normalize specific LaTeX patterns for better MathML semantics
        # ONLY if LaTeX is NOT marked clean (clean LaTeX should not be rewritten)
        if not is_clean:
            normalized_latex = self._normalize_latex_semantics(clean_latex)
            if normalized_latex != clean_latex:
                self.log.append("STEP 4.5: Applied LaTeX semantic normalization (\\stackrel ‚Üí \\xrightarrow)")
                clean_latex = normalized_latex
            else:
                self.log.append("STEP 4.5: No LaTeX normalization needed")
        else:
            self.log.append("STEP 4.5: Skipped (LaTeX is clean, no normalization)")

        # ============================================================================
        # STEP 4.6: Strip Typographic Spacing Commands (PRE-MathML, MANDATORY)
        # ============================================================================
        # MathML is SEMANTIC, never typographic
        # MUST strip: \!, \quad, \qquad, \mathrm{~}, spacing hacks
        # BEFORE LaTeX ‚Üí MathML conversion
        latex_before_spacing_strip = clean_latex
        clean_latex = self._strip_typographic_spacing(clean_latex)
        if clean_latex != latex_before_spacing_strip:
            self.log.append("STEP 4.6: Stripped typographic spacing commands (\\!, \\quad, \\qquad, \\mathrm{~})")
        else:
            self.log.append("STEP 4.6: No typographic spacing commands found")

        # ============================================================================
        # STEP 4.7: Detect and REJECT Truncated LaTeX (PRE-MathML, MANDATORY)
        # ============================================================================
        # NEVER trust truncated LaTeX (e.g., "\q", "\mathbb{R}_", incomplete commands)
        # This prevents corrupted MathML from being generated
        truncated_patterns = [
            r'\\q$',  # Incomplete \q (likely \quad or \qed truncated)
            r'\\qu$',  # Incomplete \qu (likely \quad truncated)
            r'\\su$',  # Incomplete \su (likely \sum truncated)
            r'\\le$',  # Incomplete \le (likely \leq or \left truncated)
            r'\\lef$',  # Incomplete \lef (likely \left truncated - 3 letters)
            r'\\rig$',  # Incomplete \rig (likely \right truncated - 3 letters)
            r'\\fra$',  # Incomplete \fra (likely \frac truncated - 3 letters)
            r'\\ri$',  # Incomplete \ri (likely \right truncated)
            r'\\fr$',  # Incomplete \fr (likely \frac truncated)
            r'\\ma$',  # Incomplete \ma (likely \max or \mathrm truncated)
            r'\\mathbb\{[^}]+\}_$',  # Truncated set with dangling subscript (e.g., \mathbb{R}_)
            r'\\[a-z]{1,3}$',  # Any incomplete command (1-3 letters at end) - FIXED: was 1-2, now 1-3
        ]
        
        is_truncated = False
        
        # CRITICAL: Check for unbalanced braces at the end (truncated LaTeX)
        # This catches cases like `{{` or `{` at the end
        open_braces = clean_latex.count('{')
        close_braces = clean_latex.count('}')
        if open_braces > close_braces:
            # Check if LaTeX ends with unmatched opening braces
            # Pattern: ends with one or more `{` without matching `}`
            if re.search(r'\{+\s*$', clean_latex):
                is_truncated = True
                brace_count = open_braces - close_braces
                self.log.append(f"STEP 4.7 CRITICAL: Truncated LaTeX detected - ends with unmatched opening braces (count: {brace_count})")
        
        # Check for incomplete commands
        if not is_truncated:
            for pattern in truncated_patterns:
                if re.search(pattern, clean_latex):
                    is_truncated = True
                    self.log.append(f"STEP 4.7 CRITICAL: Truncated LaTeX detected: {pattern}")
                    break
        
        if is_truncated:
            self.log.append("=" * 80)
            self.log.append("üõë STEP 4.7 FAILED: TRUNCATED LaTeX DETECTED - REJECTING")
            self.log.append("RULE: NEVER trust truncated LaTeX - FAIL SAFELY")
            self.log.append("INVALID MATH ‚Äî OUTPUT SUPPRESSED")
            self.log.append("=" * 80)
            return StrictPipelineResult(
                source_type="latex",
                clean_latex=clean_latex,
                mathml="",  # REJECTED - empty MathML
                human_readable=clean_latex,
                is_valid=False,
                corruption_score=1.0,
                validation_errors=["Truncated LaTeX detected - cannot safely convert to MathML"],
                corruption_detected=["Truncated LaTeX command detected"],
                stage_failed="truncated_latex_detection",
                used_ai=used_ai,
                log=self.log,
            )
        else:
            self.log.append("STEP 4.7: No truncated LaTeX detected")

        # ============================================================================
        # STEP 5: Convert CLEAN LaTeX ‚Üí MathML (DETERMINISTIC)
        # ============================================================================
        # LaTeX ‚Üí AST ‚Üí MathML using enhanced LatexToMathML converter (supports matrices, multi-line)
        self.log.append("STEP 5: Converting CLEAN LaTeX to MathML (deterministic latex2mathml)")
        try:
            from services.ocr.latex_to_mathml import LatexToMathML
            converter = LatexToMathML()
            mathml = converter.convert(clean_latex)
            
            if not mathml or not mathml.strip():
                raise ValueError("MathML conversion returned empty result")
            
            # Ensure proper namespace and display attribute (converter should handle this, but double-check)
            if 'xmlns=' not in mathml:
                mathml = mathml.replace('<math', '<math xmlns="http://www.w3.org/1998/Math/MathML"')
            if 'display=' not in mathml:
                mathml = mathml.replace('<math xmlns="http://www.w3.org/1998/Math/MathML"', 
                                      '<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"')
            elif 'display="inline"' in mathml:
                mathml = mathml.replace('display="inline"', 'display="block"')
            
            # CRITICAL: Check for invalid MathML (LaTeX in <mtext>) BEFORE validation
            # This prevents corrupted MathML from passing through
            if re.search(r'<mtext>.*\\[a-zA-Z]+\{', mathml):
                self.log.append("STEP 5 CRITICAL: MathML contains LaTeX in <mtext> - conversion produced invalid MathML")
                raise ValueError("MathML conversion produced invalid MathML (LaTeX in <mtext>)")
            
            self.log.append(f"STEP 5 PASSED: MathML generated (length: {len(mathml)})")
        except ImportError as e:
            # CRITICAL: ImportError means latex2mathml is not available in EXE
            error_msg = f"latex2mathml import failed: {e}"
            error_type = "ImportError"
            error_details = f"{error_type}: {error_msg}"
            logger.error(f"[StrictPipeline] {error_details}")
            logger.error("[StrictPipeline] This usually means latex2mathml is not properly bundled in EXE")
            logger.error("[StrictPipeline] Check MathpixClone.spec hiddenimports for latex2mathml modules")
            
            # Get traceback for more context if available
            import traceback
            tb_str = ''.join(traceback.format_exception(type(e), e, e.__traceback__))
            tb_summary = tb_str.split('\n')[-3:-1] if len(tb_str.split('\n')) > 3 else []
            
            self.log.append(f"STEP 5 FAILED: LaTeX ‚Üí MathML conversion error: {error_details}")
            if tb_summary:
                self.log.append(f"STEP 5 FAILED: Traceback: {' | '.join(tb_summary)}")
            self.log.append(f"STEP 5 FAILED: LaTeX input (first 200 chars): {clean_latex[:200]}")
            logger.exception("LaTeX to MathML conversion failed in strict pipeline")
            return StrictPipelineResult(
                source_type="latex",
                clean_latex=clean_latex,
                mathml="",  # FAIL SAFELY - empty MathML
                human_readable=clean_latex,
                is_valid=False,
                corruption_score=1.0,
                validation_errors=[error_details],
                corruption_detected=corruption_detected,
                stage_failed="latex_to_mathml",
                used_ai=used_ai,
                log=self.log,
            )
        except (ValueError, Exception) as e:
            # Catch conversion failures (including invalid MathML detection)
            error_msg = str(e)
            self.log.append(f"STEP 5 FAILED: LaTeX ‚Üí MathML conversion failed: {error_msg}")
            self.log.append(f"STEP 5 FAILED: LaTeX input (first 200 chars): {clean_latex[:200]}")
            logger.warning("LaTeX‚ÜíMathML failed: %s | Input (first 200 chars): %s", error_msg, clean_latex[:200])
            return StrictPipelineResult(
                source_type="latex",
                clean_latex=clean_latex,
                mathml="",  # FAIL SAFELY - empty MathML
                human_readable=clean_latex,
                is_valid=False,
                corruption_score=1.0,
                validation_errors=[f"LaTeX‚ÜíMathML conversion failed: {error_msg}"],
                corruption_detected=corruption_detected,
                stage_failed="latex_to_mathml",
                used_ai=used_ai,
                log=self.log,
            )

        # ============================================================================
        # STEP 6: Validate MathML (zero tolerance)
        # ============================================================================
        self.log.append("STEP 6: Validating MathML (zero tolerance)")
        is_mathml_valid, mathml_errors = validate_mathml_strict(mathml)
        if not is_mathml_valid:
            corruption_detected.extend(mathml_errors)
            
            # CRITICAL VIOLATIONS: REJECT MathML with LaTeX in <mtext> or other fatal errors
            critical_violations = [
                'GATEKEEPER VIOLATION: <mtext> contains LaTeX commands',
                'GATEKEEPER VIOLATION: <mtext> contains LaTeX array environment',
                'GATEKEEPER VIOLATION: JavaScript error pattern',
                'STRICTLY FORBIDDEN: "equiv" spelled via',
                'STRICTLY FORBIDDEN: "sum" spelled via',
                'STRICTLY FORBIDDEN: "mathbb" spelled via',
                'STRICTLY FORBIDDEN: operator incorrectly in <mi>',  # Operators MUST be <mo>
                'GATEKEEPER VIOLATION:.*operator in <mi>',  # Also catch gatekeeper violations
            ]
            
            has_critical_violation = any(
                any(crit in error for crit in critical_violations)
                for error in mathml_errors
            )
            
            if has_critical_violation:
                self.log.append("=" * 80)
                self.log.append("üõë STEP 6 FAILED: CRITICAL MathML VIOLATIONS DETECTED - REJECTING")
                self.log.append(f"Critical violations: {[e for e in mathml_errors if any(crit in e for crit in critical_violations)][:3]}")
                self.log.append("RULE: Invalid MathML NEVER passes - FAIL SAFELY")
                self.log.append("INVALID MATH ‚Äî OUTPUT SUPPRESSED")
                self.log.append("=" * 80)
                
                # Attempt recovery: reconstruct from LaTeX and retry
                self.log.append("STEP 6.1: Attempting recovery from LaTeX source")
                try:
                    # Re-run pipeline with original LaTeX to get clean MathML
                    recovery_result = self.process_latex(clean_latex)
                    if recovery_result.get("is_valid", False):
                        self.log.append("STEP 6.1 PASSED: Recovery successful - using recovered MathML")
                        mathml = recovery_result.get("mathml", "")
                        is_mathml_valid = True
                        mathml_errors = []
                    else:
                        self.log.append("STEP 6.1 FAILED: Recovery did not produce valid MathML")
                        # FAIL SAFELY - return empty MathML
                        return StrictPipelineResult(
                            source_type="latex",
                            clean_latex=clean_latex,
                            mathml="",  # REJECTED - empty MathML
                            human_readable=clean_latex,
                            is_valid=False,
                            corruption_score=1.0,
                            validation_errors=mathml_errors,
                            corruption_detected=corruption_detected,
                            stage_failed="mathml_validation_critical",
                            used_ai=used_ai,
                            log=self.log,
                        )
                except Exception as recovery_exc:
                    self.log.append(f"STEP 6.1 FAILED: Recovery exception: {recovery_exc}")
                    # FAIL SAFELY - return empty MathML
                    return StrictPipelineResult(
                        source_type="latex",
                        clean_latex=clean_latex,
                        mathml="",  # REJECTED - empty MathML
                        human_readable=clean_latex,
                        is_valid=False,
                        corruption_score=1.0,
                        validation_errors=mathml_errors,
                        corruption_detected=corruption_detected,
                        stage_failed="mathml_validation_critical_recovery_failed",
                        used_ai=used_ai,
                        log=self.log,
                    )
            else:
                # Non-critical violations - log warning but allow (for minor issues)
                self.log.append(f"STEP 6 WARNING: MathML validation errors (non-critical): {mathml_errors[:3]}")

        # ============================================================================
        # STEP 6.5: MathML Post-Validation Normalization (NON-STRUCTURAL)
        # ============================================================================
        # Normalize numeric entities to ASCII characters (display-level improvement only)
        # ONLY if MathML validation passed (we trust validated MathML structure)
        if is_mathml_valid:
            # Step 6.5.0: CRITICAL - Normalize operators (ensure ; and other operators are <mo>, not <mi>)
            # This must happen BEFORE other normalizations
            from services.ocr.latex_to_mathml import LatexToMathML
            converter = LatexToMathML()
            mathml_before_operator_norm = mathml
            mathml = converter._normalize_operator_tags(mathml)
            if mathml != mathml_before_operator_norm:
                self.log.append("STEP 6.5.0: Applied operator tag normalization (; and other operators ‚Üí <mo>)")
            else:
                self.log.append("STEP 6.5.0: Operator tags already correct")
            
            # Step 6.5.1: Normalize numeric entities
            normalized_mathml = self._normalize_mathml_entities(mathml)
            if normalized_mathml != mathml:
                self.log.append("STEP 6.5.1: Applied MathML entity normalization (numeric entities ‚Üí ASCII)")
                mathml = normalized_mathml
            else:
                self.log.append("STEP 6.5.1: No MathML entity normalization needed")
            
            # Step 6.5.2: Ensure double-struck sets (MANDATORY)
            # ‚Ñù, ‚Ñ§, ‚Ñï, ‚Ñö MUST use mathvariant="double-struck"
            mathml_before_double_struck = mathml
            mathml = self._ensure_double_struck_sets(mathml)
            if mathml != mathml_before_double_struck:
                self.log.append("STEP 6.5.2: Applied double-struck sets normalization")
            else:
                self.log.append("STEP 6.5.2: Double-struck sets already correct")
        else:
            self.log.append("STEP 6.5: Skipped (MathML validation failed, no normalization)")

        # ============================================================================
        # FINAL RESULT
        # ============================================================================
        self.log.append("=" * 80)
        self.log.append("PIPELINE COMPLETE")
        self.log.append("=" * 80)
        return StrictPipelineResult(
            source_type="latex",
            clean_latex=clean_latex,
            mathml=mathml,
            human_readable=self._generate_human_readable(clean_latex, mathml),
            is_valid=is_mathml_valid,  # Only valid if MathML validation passed
            corruption_score=calculate_corruption_score(clean_latex, mathml),
            validation_errors=mathml_errors,
            corruption_detected=corruption_detected,
            stage_failed=None if is_mathml_valid else "mathml_validation",
            used_ai=used_ai,
            log=self.log,
        )

    
    def _generate_human_readable(self, latex: str, mathml: str) -> str:
        """
        Generate human-readable equation (plain text math).
        
        Converts LaTeX to readable format for display.
        """
        if not latex:
            return ""
        
        # Basic conversion: remove LaTeX commands, keep structure
        readable = latex
        
        # Replace common LaTeX commands with readable equivalents
        replacements = {
            r'\\equiv': '‚â°',
            r'\\sum': '‚àë',
            r'\\in': '‚àà',
            r'\\mathbb\{Z\}': '‚Ñ§',
            r'\\mathbb\{([A-Z])\}': r'\1',  # \mathbb{X} ‚Üí X (for display)
            r'\\left': '',
            r'\\right': '',
            r'\\cdot': '¬∑',
            r'\\times': '√ó',
            r'\\leq': '‚â§',
            r'\\geq': '‚â•',
            r'\\neq': '‚â†',
        }
        
        for pattern, replacement in replacements.items():
            readable = re.sub(pattern, replacement, readable)
        
        # Clean up extra spaces
        readable = re.sub(r'\s+', ' ', readable).strip()
        
        return readable
    
    def _normalize_latex_semantics(self, latex: str) -> str:
        r"""
        SAFE LaTeX Normalization (PRE-MathML, deterministic only).
        
        Normalizes \stackrel patterns for better MathML semantics.
        latex2mathml doesn't support \stackrel well, so we convert to \xrightarrow/\xleftarrow.
        
        Patterns handled:
        - \stackrel{}{\longrightarrow}_{X} ‚Üí \xrightarrow[X]{}
        - \stackrel{}{\longleftarrow}_{X} ‚Üí \xleftarrow[X]{}
        - \stackrel{top}{bottom} ‚Üí \xrightarrow[bottom]{top} (if bottom contains arrow-like content)
        - \stackrel{\longrightarrow}{content} ‚Üí \xrightarrow{content}
        - \stackrel{content}{\longrightarrow} ‚Üí \xrightarrow{content}
        
        Rules:
        - Apply ONLY if \xrightarrow / \xleftarrow is NOT already present
        - Do NOT rewrite any other LaTeX
        - Do NOT change spacing, symbols, or macros
        - This is called ONLY if LaTeX is NOT marked "clean"
        
        Returns normalized LaTeX (unchanged if no normalization needed).
        """
        if not latex:
            return latex
        
        # Skip if target patterns already exist (avoid double conversion)
        if '\\xrightarrow' in latex or '\\xleftarrow' in latex:
            return latex
        
        normalized = latex
        
        # Pattern 1: \stackrel{}{\longrightarrow}_{X} ‚Üí \xrightarrow[X]{}
        # Match: \stackrel{}{} followed by \longrightarrow followed by _{X}
        pattern1 = r'\\stackrel\s*\{\s*\}\s*\{\s*\}\s*\\longrightarrow\s*_\s*\{([^}]+)\}'
        replacement1 = r'\\xrightarrow[\1]{}'
        normalized = re.sub(pattern1, replacement1, normalized)
        
        # Pattern 2: \stackrel{}{\longleftarrow}_{X} ‚Üí \xleftarrow[X]{}
        pattern2 = r'\\stackrel\s*\{\s*\}\s*\{\s*\}\s*\\longleftarrow\s*_\s*\{([^}]+)\}'
        replacement2 = r'\\xleftarrow[\1]{}'
        normalized = re.sub(pattern2, replacement2, normalized)
        
        # Pattern 3: \stackrel{}{\longrightarrow} (no subscript) ‚Üí \xrightarrow{}
        pattern3 = r'\\stackrel\s*\{\s*\}\s*\{\s*\}\s*\\longrightarrow\b'
        replacement3 = r'\\xrightarrow{}'
        normalized = re.sub(pattern3, replacement3, normalized)
        
        # Pattern 4: \stackrel{}{\longleftarrow} (no subscript) ‚Üí \xleftarrow{}
        pattern4 = r'\\stackrel\s*\{\s*\}\s*\{\s*\}\s*\\longleftarrow\b'
        replacement4 = r'\\xleftarrow{}'
        normalized = re.sub(pattern4, replacement4, normalized)
        
        # Pattern 5: \stackrel{\longrightarrow}{content} ‚Üí \xrightarrow{content}
        # First brace contains \longrightarrow, second brace contains content
        pattern5 = r'\\stackrel\s*\{\s*\\longrightarrow\s*\}\s*\{([^}]+)\}'
        replacement5 = r'\\xrightarrow{\1}'
        normalized = re.sub(pattern5, replacement5, normalized)
        
        # Pattern 6: \stackrel{content}{\longrightarrow} ‚Üí \xrightarrow{content}
        # First brace contains content, second brace contains \longrightarrow
        pattern6 = r'\\stackrel\s*\{([^}]+)\}\s*\{\s*\\longrightarrow\s*\}'
        replacement6 = r'\\xrightarrow{\1}'
        normalized = re.sub(pattern6, replacement6, normalized)
        
        # Pattern 7: \stackrel{top}{bottom} where bottom looks like a condition
        # If bottom contains patterns like (R_1,...,R_K)‚ààC(P), treat as \xrightarrow[bottom]{top}
        # This is more aggressive but handles common cases
        pattern7 = r'\\stackrel\s*\{([^}]+)\}\s*\{([^}]+)\}'
        def replace_stacked(match):
            top = match.group(1).strip()
            bottom = match.group(2).strip()
            # If bottom contains ‚àà, =, or looks like a condition, use subscript form
            if re.search(r'[‚àà=<>‚â§‚â•]', bottom) or '(' in bottom:
                return f'\\xrightarrow[{bottom}]{{{top}}}'
            # Otherwise, just use top as content
            return f'\\xrightarrow{{{top}}}'
        
        # Only apply pattern7 if we still have \stackrel (not already converted)
        if '\\stackrel' in normalized:
            normalized = re.sub(pattern7, replace_stacked, normalized)
        
        return normalized
    
    def _fix_stacked_operators_in_mathml(self, mathml: str) -> str:
        r"""
        Fix \stackrel appearing as literal text in MathML.
        
        latex2mathml doesn't support \stackrel well, so it may appear as:
        - <mi>\stackrel</mi>
        - <mi>\\stackrel</mi>
        
        This violates the "no LaTeX in MathML" rule. We need to detect and fix this.
        
        Strategy:
        1. Find <mi>\stackrel</mi> or <mi>\\stackrel</mi>
        2. Look for surrounding context (arrow symbols, content)
        3. Replace with proper MathML structure using <mover> or <munderover>
        
        Returns fixed MathML.
        """
        if not mathml or '\\stackrel' not in mathml:
            return mathml
        
        import xml.etree.ElementTree as ET
        
        try:
            root = ET.fromstring(mathml)
        except Exception:
            # If parsing fails, try regex-based fix
            return self._fix_stacked_operators_regex(mathml)
        
        ns = "{http://www.w3.org/1998/Math/MathML}"
        changed = False
        
        # Find all <mi> elements containing \stackrel
        for mi in root.iter():
            if (mi.tag == f"{ns}mi" or mi.tag == "mi") and mi.text:
                text = mi.text.strip()
                if '\\stackrel' in text or 'stackrel' in text:
                    # Found \stackrel as literal text - need to fix
                    # This is complex, so we'll use a simpler approach:
                    # Replace the entire expression with a warning marker
                    # The pipeline should have normalized this before MathML conversion
                    logger.warning("Found \\stackrel as literal text in MathML - this should have been normalized in LaTeX")
                    # For now, replace with a placeholder that indicates the issue
                    # In production, this should trigger a re-conversion with normalized LaTeX
                    mi.text = "‚Üí"  # Simple arrow as fallback
                    changed = True
        
        if changed:
            try:
                ET.indent(root, space="  ")
            except AttributeError:
                pass
            return ET.tostring(root, encoding="unicode", method="xml")
        
        return mathml
    
    def _fix_stacked_operators_regex(self, mathml: str) -> str:
        r"""
        Regex-based fix for \stackrel in MathML (fallback if XML parsing fails).
        
        This is a simpler approach that just removes the literal \stackrel text.
        """
        # Pattern: <mi>\stackrel</mi> or <mi>\\stackrel</mi>
        pattern = r'<mi>\\?stackrel</mi>'
        # Replace with a simple arrow operator
        fixed = re.sub(pattern, '<mo>‚Üí</mo>', mathml)
        return fixed
    
    def _strip_typographic_spacing(self, latex: str) -> str:
        """
        Strip typographic spacing commands from LaTeX (MANDATORY before MathML conversion).
        
        MathML is SEMANTIC, never typographic.
        MUST strip: \\!, \\quad, \\qquad, \\mathrm{~}, spacing hacks
        
        Rules:
        - Remove ALL spacing commands
        - Do NOT change mathematical content
        - Do NOT change structure
        - Deterministic replacement
        
        Returns LaTeX with spacing commands removed.
        """
        if not latex:
            return latex
        
        stripped = latex
        
        # Remove negative space
        stripped = re.sub(r'\\!+', '', stripped)
        
        # Remove quad spacing
        stripped = re.sub(r'\\quad+', '', stripped)
        stripped = re.sub(r'\\qquad+', '', stripped)
        
        # Remove \mathrm{~} and similar spacing hacks
        stripped = re.sub(r'\\mathrm\s*\{\s*~\s*\}', '', stripped)
        stripped = re.sub(r'\\text\s*\{\s*~\s*\}', '', stripped)
        
        # Remove explicit spacing commands
        stripped = re.sub(r'\\hspace\s*\{[^}]+\}', '', stripped)
        stripped = re.sub(r'\\hskip\s*[0-9.]+(?:pt|em|ex|mu)', '', stripped)
        
        # Remove \, \: \; (thin, medium, thick space)
        stripped = re.sub(r'\\[,:;]', '', stripped)
        
        return stripped
    
    def _ensure_double_struck_sets(self, mathml: str) -> str:
        """
        Ensure sets use mathvariant="double-struck" for ‚Ñù, ‚Ñ§, etc. (MANDATORY).
        
        Rules:
        - Replace plain <mi>R</mi> with <mi mathvariant="double-struck">R</mi> for ‚Ñù
        - Replace plain <mi>Z</mi> with <mi mathvariant="double-struck">Z</mi> for ‚Ñ§
        - Only if they represent sets (context-dependent, but be conservative)
        - Do NOT change if already has mathvariant
        - Do NOT change structure
        - This is a post-validation fix, so MathML structure is trusted
        
        Returns MathML with double-struck sets ensured.
        """
        if not mathml:
            return mathml
        
        normalized = mathml
        
        # Check if double-struck is already present (skip if already correct)
        has_double_struck = 'mathvariant="double-struck"' in normalized or '‚Ñù' in normalized or '‚Ñ§' in normalized
        
        # Pattern: <mi>R</mi> that should be ‚Ñù (real numbers)
        # Replace only if we see evidence of \mathbb{R} in context
        # Be conservative: only replace standalone R (not in subscripts/superscripts)
        if '\\mathbb{R}' in normalized or 'mathbb{R}' in normalized or '‚Ñù' in normalized:
            # Replace <mi>R</mi> with double-struck, but avoid variables like R_i, R_1
            # Only replace if R is not part of a subscript structure
            # Find all <mi>R</mi> and check context manually (avoid variable-width lookbehind)
            matches = list(re.finditer(r'<mi>R</mi>', normalized))
            for match in reversed(matches):  # Process from end to avoid index shifts
                start = match.start()
                # Check if this R is inside a <msub> or <msup> structure
                # Look backwards for the nearest opening tag
                before = normalized[:start]
                # Check if we're inside <msub>...</msub> or <msup>...</msup>
                # Count unclosed <msub> and <msup> tags before this position
                msub_before = before.count('<msub')
                msub_close_before = before.count('</msub>')
                msup_before = before.count('<msup')
                msup_close_before = before.count('</msup>')
                
                # If we're inside a subscript/superscript structure, skip
                if (msub_before > msub_close_before) or (msup_before > msup_close_before):
                    continue
                
                # Check if already has mathvariant
                if 'mathvariant="double-struck"' in before[max(0, start-50):start]:
                    continue
                
                # Safe to replace
                normalized = normalized[:start] + '<mi mathvariant="double-struck">R</mi>' + normalized[match.end():]
                self.log.append("STEP 6.5: Fixed ‚Ñù (replaced <mi>R</mi> with mathvariant=\"double-struck\")")
        
        # Pattern: <mi>Z</mi> that should be ‚Ñ§ (integers)
        if '\\mathbb{Z}' in normalized or 'mathbb{Z}' in normalized or '‚Ñ§' in normalized:
            # Similar approach for Z
            matches = list(re.finditer(r'<mi>Z</mi>', normalized))
            for match in reversed(matches):  # Process from end to avoid index shifts
                start = match.start()
                before = normalized[:start]
                # Check if we're inside a subscript/superscript structure
                msub_before = before.count('<msub')
                msub_close_before = before.count('</msub>')
                msup_before = before.count('<msup')
                msup_close_before = before.count('</msup>')
                
                # If we're inside a subscript/superscript structure, skip
                if (msub_before > msub_close_before) or (msup_before > msup_close_before):
                    continue
                
                # Check if already has mathvariant
                if 'mathvariant="double-struck"' in before[max(0, start-50):start]:
                    continue
                
                # Safe to replace
                normalized = normalized[:start] + '<mi mathvariant="double-struck">Z</mi>' + normalized[match.end():]
                self.log.append("STEP 6.5: Fixed ‚Ñ§ (replaced <mi>Z</mi> with mathvariant=\"double-struck\")")
        
        return normalized
    
    def _normalize_mathml_entities(self, mathml: str) -> str:
        """
        MathML Post-Validation Normalization (NON-STRUCTURAL).
        
        Replaces numeric entities like &#x00043; with actual ASCII characters.
        
        Rules:
        - ASCII letters and digits ONLY (A-Z, a-z, 0-9)
        - DO NOT change tags
        - DO NOT change nesting
        - DO NOT add/remove elements
        - Run ONLY if MathML is already validated
        - This is a display-level improvement, not structural editing
        
        Returns normalized MathML (unchanged if no normalization needed).
        """
        if not mathml:
            return mathml
        
        normalized = mathml
        
        # Map common numeric entities to ASCII characters
        # Only handle ASCII letters (A-Z, a-z) and digits (0-9)
        entity_map = {
            '&#x00041;': 'A', '&#x00042;': 'B', '&#x00043;': 'C', '&#x00044;': 'D',
            '&#x00045;': 'E', '&#x00046;': 'F', '&#x00047;': 'G', '&#x00048;': 'H',
            '&#x00049;': 'I', '&#x0004A;': 'J', '&#x0004B;': 'K', '&#x0004C;': 'L',
            '&#x0004D;': 'M', '&#x0004E;': 'N', '&#x0004F;': 'O', '&#x00050;': 'P',
            '&#x00051;': 'Q', '&#x00052;': 'R', '&#x00053;': 'S', '&#x00054;': 'T',
            '&#x00055;': 'U', '&#x00056;': 'V', '&#x00057;': 'W', '&#x00058;': 'X',
            '&#x00059;': 'Y', '&#x0005A;': 'Z',
            '&#x00061;': 'a', '&#x00062;': 'b', '&#x00063;': 'c', '&#x00064;': 'd',
            '&#x00065;': 'e', '&#x00066;': 'f', '&#x00067;': 'g', '&#x00068;': 'h',
            '&#x00069;': 'i', '&#x0006A;': 'j', '&#x0006B;': 'k', '&#x0006C;': 'l',
            '&#x0006D;': 'm', '&#x0006E;': 'n', '&#x0006F;': 'o', '&#x00070;': 'p',
            '&#x00071;': 'q', '&#x00072;': 'r', '&#x00073;': 's', '&#x00074;': 't',
            '&#x00075;': 'u', '&#x00076;': 'v', '&#x00077;': 'w', '&#x00078;': 'x',
            '&#x00079;': 'y', '&#x0007A;': 'z',
            '&#x00030;': '0', '&#x00031;': '1', '&#x00032;': '2', '&#x00033;': '3',
            '&#x00034;': '4', '&#x00035;': '5', '&#x00036;': '6', '&#x00037;': '7',
            '&#x00038;': '8', '&#x00039;': '9',
        }
        
        # Replace entities within <mi> tags only (identifiers)
        # Pattern: <mi>&#x00043;</mi> ‚Üí <mi>C</mi>
        for entity, char in entity_map.items():
            pattern = f'<mi>{re.escape(entity)}</mi>'
            replacement = f'<mi>{char}</mi>'
            normalized = re.sub(pattern, replacement, normalized)
        
        return normalized
    
    def _apply_letter_by_letter_fixes(self, latex: str) -> str:
        """
        Apply letter-by-letter corruption fixes to LaTeX.
        This is a helper method that can be called multiple times.
        """
        if not latex:
            return latex
        
        fixed_latex = latex
        letter_by_letter_fixes = [
            # \c_{a}l ‚Üí \cal or \mathcal (calligraphic)
            (r'\\c_\{a\}l\b', r'\\cal'),
            (r'\\c_\{a\}l\s*\{', r'\\mathcal{'),
            # \l_{o}n_{g}r_{i}g_{h}t_{a}r_{r}o_{w} ‚Üí \longrightarrow (handle with or without spacing)
            (r'\\l_\{o\}n_\{g\}r_\{i\}g_\{h\}t_\{a\}r_\{r\}o_\{w\}', r'\\longrightarrow'),
            (r'\\l_\{o\}\s*n_\{g\}\s*r_\{i\}\s*g_\{h\}\s*t_\{a\}\s*r_\{r\}\s*o_\{w\}', r'\\longrightarrow'),
            # \l_{e}f_{t} ‚Üí \left
            (r'\\l_\{e\}f_\{t\}', r'\\left'),
            # \r_{i}g_{h}t ‚Üí \right
            (r'\\r_\{i\}g_\{h\}t\b', r'\\right'),
            # \s_{u}m ‚Üí \sum
            (r'\\s_\{u\}m\b', r'\\sum'),
            # \m_{a}t_{h}b_{b} ‚Üí \mathbb
            (r'\\m_\{a\}t_\{h\}b_\{b\}', r'\\mathbb'),
            # \e_{q}u_{i}v ‚Üí \equiv
            (r'\\e_\{q\}u_\{i\}v\b', r'\\equiv'),
            # \f_{r}a_{c} ‚Üí \frac
            (r'\\f_\{r\}a_\{c\}', r'\\frac'),
            # \b_{e}g_{i}n ‚Üí \begin
            (r'\\b_\{e\}g_\{i\}n\b', r'\\begin'),
            # \e_{n}d ‚Üí \end
            (r'\\e_\{n\}d\b', r'\\end'),
            # \a_{r}r_{a}y ‚Üí \array
            (r'\\a_\{r\}r_\{a\}y\b', r'\\array'),
            # \c_{d}o_{t} ‚Üí \cdot (dot product)
            (r'\\c_\{d\}o_\{t\}', r'\\cdot'),
            (r'\\c_\{d\}\s*o_\{t\}', r'\\cdot'),
        ]
        
        for pattern, replacement in letter_by_letter_fixes:
            fixed_latex = re.sub(pattern, replacement, fixed_latex)
        
        return fixed_latex
    
    def _mandatory_openai_cleanup(self, corrupted_latex: str, corruption_patterns: List[str]) -> str:
        """
        MANDATORY: Send corrupted LaTeX to OpenAI to restore true mathematical intent.
        
        GATEKEEPER RULES:
        - OpenAI is FORBIDDEN from handling clean LaTeX
        - OpenAI is ONLY used for shredded/corrupted LaTeX
        - If LaTeX is clean, this function should NOT be called
        
        This is MANDATORY when corruption is detected - not optional.
        
        SEMANTIC FIX RULES:
        - Replace broken tokens with real operators (s_u_m ‚Üí \\sum)
        - NEVER preserve broken structures
        - Prefer mathematical meaning over OCR similarity
        - If semantic correctness CANNOT be guaranteed, return empty string
        - NEVER guess operators or symbols
        """
        # GATEKEEPER CHECK: Verify LaTeX is actually corrupted before calling OpenAI
        if is_semantically_clean_latex(corrupted_latex):
            self.log.append("=" * 80)
            self.log.append("üö´ GATEKEEPER VIOLATION: Attempted to call OpenAI on CLEAN LaTeX")
            self.log.append("RULE: OpenAI is FORBIDDEN from handling clean LaTeX")
            self.log.append("RULE: Clean LaTeX must pass directly to deterministic converter")
            self.log.append("=" * 80)
            # Return clean LaTeX as-is (DO NOT call OpenAI)
            return corrupted_latex
        
        # ============================================================================
        # PRE-FIX: Handle truncated/incomplete LaTeX BEFORE sending to OpenAI
        # ============================================================================
        cleaned_latex = corrupted_latex
        
        # STEP 3.0.1: Fix common letter-by-letter corruption patterns BEFORE OpenAI
        # This helps when OpenAI fails or returns executable code
        self.log.append("STEP 3.0.1: Applying letter-by-letter corruption fixes")
        cleaned_latex_before = cleaned_latex
        cleaned_latex = self._apply_letter_by_letter_fixes(cleaned_latex)
        
        if cleaned_latex != cleaned_latex_before:
            fixes_applied = len(re.findall(r'\\[a-z]+\{', cleaned_latex)) - len(re.findall(r'\\[a-z]+\{', cleaned_latex_before))
            self.log.append(f"STEP 3.0.1: Applied letter-by-letter fixes (LaTeX changed)")
            self.log.append(f"STEP 3.0.1: LaTeX after fixes: {cleaned_latex[:150]}...")
        
        # Check for incomplete/truncated LaTeX commands at the end
        truncated_patterns = [
            (r'\\q$', ''),  # Remove incomplete \q (likely \quad or \qed truncated)
            (r'\\qu$', ''),  # Remove incomplete \qu (likely \quad truncated)
            (r'\\su$', ''),  # Remove incomplete \su (likely \sum truncated)
            (r'\\le$', ''),  # Remove incomplete \le (likely \leq or \left truncated)
            (r'\\ri$', ''),  # Remove incomplete \ri (likely \right truncated)
            (r'\\fr$', ''),  # Remove incomplete \fr (likely \frac truncated)
            (r'\\ma$', ''),  # Remove incomplete \ma (likely \max or \mathrm truncated)
        ]
        
        for pattern, replacement in truncated_patterns:
            if re.search(pattern, cleaned_latex):
                self.log.append(f"STEP 3.0: Detected incomplete LaTeX command, removing: {pattern}")
                cleaned_latex = re.sub(pattern, replacement, cleaned_latex)
        
        # Also check if LaTeX ends with incomplete command (single backslash + 1-2 letters)
        if re.search(r'\\[a-z]{1,2}$', cleaned_latex):
            self.log.append("STEP 3.0: Detected LaTeX ending with incomplete command, removing it")
            cleaned_latex = re.sub(r'\\[a-z]{1,2}$', '', cleaned_latex)
        
        # Check for unbalanced braces/brackets in truncated LaTeX
        open_braces = cleaned_latex.count('{')
        close_braces = cleaned_latex.count('}')
        open_brackets = cleaned_latex.count('[')
        close_brackets = cleaned_latex.count(']')
        
        # Check for unbalanced \left/\right pairs (CRITICAL for ExtraLeftOrMissingRightError)
        left_count = len(re.findall(r'\\left[^a-zA-Z]', cleaned_latex))
        right_count = len(re.findall(r'\\right[^a-zA-Z]', cleaned_latex))
        
        # If more \right than \left, remove extra \right pairs from the end
        if right_count > left_count:
            extra_rights = right_count - left_count
            self.log.append(f"STEP 3.0: Detected {extra_rights} extra \\right commands (left={left_count}, right={right_count}), removing from end")
            # Remove extra \right} or \right) or \right] from the end
            # Work backwards from the end to preserve structure
            for _ in range(extra_rights):
                # Most common case: \right\} at the end (possibly with trailing punctuation like .)
                if cleaned_latex.rstrip().endswith('\\right}'):
                    # Remove \right} from the end, but preserve trailing punctuation
                    cleaned_latex = re.sub(r'\\right\}([^}]*)$', r'\1', cleaned_latex.rstrip(), count=1).rstrip()
                elif cleaned_latex.rstrip().endswith('\\right)'):
                    cleaned_latex = re.sub(r'\\right\)([^)]*)$', r'\1', cleaned_latex.rstrip(), count=1).rstrip()
                elif cleaned_latex.rstrip().endswith('\\right]'):
                    cleaned_latex = re.sub(r'\\right\]([^\]]*)$', r'\1', cleaned_latex.rstrip(), count=1).rstrip()
                else:
                    # Fallback: find last occurrence of \right followed by delimiter and remove it
                    # Match from end: \right followed by }, ), or ]
                    match = re.search(r'\\right([}\]\)])([^\\]*)$', cleaned_latex)
                    if match:
                        # Remove the \right and delimiter, but keep trailing text
                        cleaned_latex = cleaned_latex[:match.start()] + match.group(2)
                    else:
                        # Last resort: remove any \right followed by delimiter (from end)
                        cleaned_latex = re.sub(r'\\right([}\]\)])(?=[^\\]*$)', '', cleaned_latex, count=1)
        
        # If more \left than \right, add missing \right pairs at the end
        if left_count > right_count:
            missing_rights = left_count - right_count
            self.log.append(f"STEP 3.0: Detected {missing_rights} missing \\right commands, adding at end")
            # Try to determine what delimiter to use based on the last \left
            last_left_match = list(re.finditer(r'\\left([^a-zA-Z])', cleaned_latex))
            if last_left_match:
                last_delim = last_left_match[-1].group(1)
                # Map opening to closing delimiters
                delim_map = {'(': ')', '[': ']', '{': '}', '|': '|', '.': '.'}
                closing = delim_map.get(last_delim, '}')
                cleaned_latex += '\\right' + closing
        
        # If significantly unbalanced, try to close them (but be conservative)
        if open_braces > close_braces + 2:  # More than 2 unclosed braces
            missing = open_braces - close_braces
            self.log.append(f"STEP 3.0: Detected {missing} unclosed braces, attempting to close")
            cleaned_latex += '}' * missing
        elif close_braces > open_braces + 2:  # More than 2 extra closing braces
            extra = close_braces - open_braces
            self.log.append(f"STEP 3.0: Detected {extra} extra closing braces, removing from end")
            # Remove extra closing braces from the end (but be careful not to break structure)
            for _ in range(min(extra, 5)):  # Limit to 5 removals to avoid over-correction
                if cleaned_latex.endswith('}'):
                    cleaned_latex = cleaned_latex[:-1]
        
        if open_brackets > close_brackets + 2:  # More than 2 unclosed brackets
            missing = open_brackets - close_brackets
            self.log.append(f"STEP 3.0: Detected {missing} unclosed brackets, attempting to close")
            cleaned_latex += ']' * missing
        elif close_brackets > open_brackets + 2:  # More than 2 extra closing brackets
            extra = close_brackets - open_brackets
            self.log.append(f"STEP 3.0: Detected {extra} extra closing brackets, removing from end")
            # Remove extra closing brackets from the end
            for _ in range(min(extra, 5)):  # Limit to 5 removals
                if cleaned_latex.endswith(']'):
                    cleaned_latex = cleaned_latex[:-1]
        
        # Store original for comparison
        original_latex = corrupted_latex
        
        try:
            from services.ocr.openai_mathml_converter import OpenAIMathMLConverter
            from core.config import settings
            
            api_key = getattr(settings, 'openai_api_key', None)
            if not api_key:
                self.log.append("ERROR: OpenAI API key required for MANDATORY cleanup but not found")
                return corrupted_latex
            
            self.log.append("MANDATORY: Initializing OpenAI for LaTeX cleanup")
            converter = OpenAIMathMLConverter(
                api_key=api_key,
                model=getattr(settings, 'openai_model', 'gpt-4o-mini')
            )
            
            # Build context about corruption (MANDATORY instructions)
            # Check if LaTeX is incomplete/truncated
            is_truncated = (
                cleaned_latex.endswith('\\q') or 
                cleaned_latex.endswith('\\qu') or
                re.search(r'\\[a-z]{1,2}$', cleaned_latex) or
                (cleaned_latex.count('{') > cleaned_latex.count('}') + 2) or
                (cleaned_latex.count('[') > cleaned_latex.count(']') + 2) or
                len(cleaned_latex) < len(original_latex)  # We removed something
            )
            
            truncation_note = ""
            if is_truncated:
                truncation_note = """
‚ö†Ô∏è CRITICAL: The input LaTeX appears to be INCOMPLETE/TRUNCATED (ends abruptly or has incomplete commands).
- Complete the equation based on mathematical context
- Close any unclosed braces {} or brackets []
- If the equation is clearly incomplete, reconstruct the missing parts based on mathematical structure
- Common truncations: \\q (likely \\quad), \\su (likely \\sum), incomplete operators
- The LaTeX may have been pre-cleaned to remove incomplete commands - reconstruct the full equation
"""
            
            context = f"""You are a MathOCR semantic reconstruction engine.
{truncation_note}

Input may contain CORRUPTED LaTeX where operators are spelled using subscripts
(e.g., f_r a_c, s_u m, l_e f_t, r_i g_h t, l_{{e}}f_{{t}}, r_{{i}}g_{{h}}t).

üö´ MANDATORY RULES:
- NEVER preserve broken tokens.
- NEVER output LaTeX that spells words via subscripts.
- ALWAYS reconstruct correct mathematical operators.
- FIX missing or corrupted special characters (braces, brackets, operators).
- ENSURE all LaTeX commands are complete and valid.

CORRUPTION DETECTED:
{chr(10).join(f"- {pattern}" for pattern in corruption_patterns[:15])}

‚úÖ REWRITE RULES (RECONSTRUCT FROM SEMANTICS - NOT OCR TOKENS):
- f_r a_c ‚Üí \\frac
- s_u_m ‚Üí \\sum
- l_e_f_t or l_{{e}}f_{{t}} ‚Üí \\left
- r_i_g_h_t or r_{{i}}g_{{h}}t ‚Üí \\right
- l_e_q ‚Üí \\leq
- m_a_t_h_b_b ‚Üí \\mathbb
- e_q_u_i_v ‚Üí \\equiv
- l_o_n_g ‚Üí \\longrightarrow
- b_f ‚Üí \\mathbf
- i n Z ‚Üí i \\in \\mathbb{{Z}}
- Z(j) ‚Üí \\mathbb{{Z}}(j) (if Z represents integers)
- Missing braces: fix unbalanced {{}} pairs
- Missing brackets: fix unbalanced [] pairs
- Missing operators: add =, +, -, etc. if semantically required
- Special characters: preserve or fix Unicode math symbols (‚àà, ‚àë, ‚â°, etc.)

‚ùå NEVER preserve broken tokens
‚ùå NEVER "fix" letter-by-letter
‚úÖ ALWAYS reconstruct from mathematical meaning
‚úÖ FIX missing special characters and operators
‚úÖ ENSURE proper LaTeX syntax (balanced braces, valid commands)

CRITICAL EXAMPLES:
If input is "P_{{s_1,d_1}}~=~l_{{e}}f_{{t}}{{s_1,v_1,v_2,v_3,d_1}}r_{{i}}g_{{h}}t", output:
P_{{{s_1,d_1}}} = \\left\\{{s_1,v_1,v_2,v_3,d_1\\right\\}}

If input is "Y_j[t] s_u_m i in Z(j)", output:
Y_j[t] = \\sum_{{i \\in \\mathbb{{Z}}(j)}}

If input has missing = operator, add it: "Y_j[t] sum" ‚Üí "Y_j[t] = \\sum"

üß† SEMANTIC RECONSTRUCTION PRIORITY:
- RECONSTRUCT FROM SEMANTICS, not fix tokens
- If visual OCR conflicts with math meaning, ALWAYS choose mathematical meaning
- Discard corrupted tokens and rebuild from mathematical structure
- FIX missing special characters (braces, brackets, operators) based on context
- ENSURE LaTeX is syntactically valid and semantically correct

OUTPUT FORMAT (JSON ONLY - CRITICAL):
{{
  "latex": "<clean semantic latex with all special characters fixed>",
  "confidence": 0.90
}}

üö´ CRITICAL: Output ONLY valid JSON text. DO NOT:
- Execute any Python code
- Use code blocks with executable code
- Include variable assignments (e.g., s_1 = ..., d_1 = ...)
- Include function calls or imports
- Use any programming language syntax

‚úÖ REQUIRED: Return ONLY a JSON object as plain text, for example:
{{"latex": "\\mathbf{{D}}=\\left\\{{(D_{{1}},...,D_{{K}})\\in\\mathbb{{R}}_{{+}}^{{K}}:\\forall w_{{1}},...,w_{{K}}\\in\\mathbb{{R}}_{{+}},\\sum_{{i=1}}^{{K}}w_{{i}}D_{{i}}\\le\\lim_{{P\\to\\infty}}\\left(\\sup_{{(R_{{1}},...,R_{{K}})\\in\\mathcal{{C}}(P)}}\\frac{{w_{{1}}R_{{1}}+...+w_{{K}}R_{{K}}}}{{\\frac{{1}}{{2}}\\log P}}\\right)\\right\\}}", "confidence": 0.95}}

Output ONLY valid JSON, no explanations, no markdown, no code blocks, no Python code."""
            
            self.log.append("MANDATORY: Calling OpenAI to RECONSTRUCT from semantics (not fix tokens)")
            self.log.append(f"MANDATORY: Input LaTeX (pre-cleaned): {cleaned_latex[:100]}...")
            # NOTE: We use convert_latex_to_mathml_strict here, but ONLY extract LaTeX output.
            # OpenAI is ONLY used for LaTeX semantic rewriting - we IGNORE any MathML output.
            # MathML must come from deterministic LaTeX‚ÜíMathML compiler (latex2mathml), NOT OpenAI.
            # Use cleaned_latex (with truncation fixes) instead of corrupted_latex
            try:
                result = converter.convert_latex_to_mathml_strict(
                    cleaned_latex,  # Use pre-cleaned version (with truncation fixes)
                    context=context
                )
            except ValueError as json_err:
                # JSON-only violation - OpenAI returned markdown/prose instead of JSON
                error_msg = str(json_err)
                self.log.append(f"MANDATORY: OpenAI violated JSON-only requirement: {error_msg}")
                self.log.append("CRITICAL: OpenAI returned markdown/prose instead of JSON - REJECTING")
                # Return pre-cleaned version (don't use OpenAI output if it violates JSON-only rule)
                if cleaned_latex != original_latex:
                    self.log.append("MANDATORY: Using pre-cleaned LaTeX (with truncation fixes) as fallback")
                    return cleaned_latex
                return original_latex
            except (NameError, SyntaxError) as code_err:
                # Catch code execution errors from OpenAI converter
                error_msg = str(code_err)
                self.log.append(f"MANDATORY: Code execution error in OpenAI converter: {error_msg}")
                self.log.append("ERROR: OpenAI response likely contains executable code")
                # Return pre-cleaned version immediately
                if cleaned_latex != original_latex:
                    self.log.append("MANDATORY: Using pre-cleaned LaTeX (with truncation fixes) as fallback")
                    return cleaned_latex
                return original_latex
            
            # Parse JSON response if needed
            # IMPORTANT: Only extract LaTeX - ignore any MathML that might be in the result
            # Safely extract values with proper error handling
            try:
                ai_cleaned_latex = result.get("latex", cleaned_latex) if isinstance(result, dict) else cleaned_latex
                confidence = result.get("confidence", 0.0) if isinstance(result, dict) else 0.0
            except (NameError, SyntaxError, AttributeError, TypeError) as extract_err:
                # If accessing result properties causes code execution errors, use fallback
                error_msg = str(extract_err)
                self.log.append(f"MANDATORY: Error extracting values from OpenAI result: {error_msg}")
                self.log.append("MANDATORY: Using pre-cleaned LaTeX (with truncation fixes) as fallback")
                if cleaned_latex != original_latex:
                    return cleaned_latex
                return original_latex
            
            # If result is a string that looks like JSON, parse it
            if isinstance(ai_cleaned_latex, str) and ai_cleaned_latex.strip().startswith('{'):
                try:
                    import json
                    parsed = json.loads(ai_cleaned_latex)
                    ai_cleaned_latex = parsed.get("latex", cleaned_latex)
                    confidence = parsed.get("confidence", confidence)
                    self.log.append(f"MANDATORY: Parsed JSON response from OpenAI (confidence: {confidence:.2f})")
                except (json.JSONDecodeError, AttributeError, TypeError) as parse_err:
                    self.log.append(f"MANDATORY: OpenAI response is not valid JSON: {parse_err}")
                    # Try to extract LaTeX from the string if it contains LaTeX-like content
                    if '\\' in ai_cleaned_latex or '{' in ai_cleaned_latex:
                        # Might be LaTeX directly, not JSON - use it
                        self.log.append("MANDATORY: Treating response as LaTeX (not JSON)")
                    else:
                        # Invalid response, use pre-cleaned version
                        ai_cleaned_latex = cleaned_latex
                        confidence = 0.0
            
            # Use AI-cleaned LaTeX if it's different and has good confidence
            final_latex = ai_cleaned_latex if (ai_cleaned_latex != cleaned_latex and confidence > 0.5) else cleaned_latex
            
            # CRITICAL: Strip typographic spacing from OpenAI output (MANDATORY)
            # MathML is SEMANTIC, never typographic - spacing commands must be removed
            if final_latex:
                final_latex_before_strip = final_latex
                final_latex = self._strip_typographic_spacing(final_latex)
                if final_latex != final_latex_before_strip:
                    self.log.append("MANDATORY: Stripped typographic spacing from OpenAI-reconstructed LaTeX")
            
            if final_latex != original_latex and confidence > 0.5:
                self.log.append(f"MANDATORY: OpenAI RECONSTRUCTED clean LaTeX from semantics (confidence: {confidence:.2f})")
                return final_latex
            else:
                self.log.append(f"MANDATORY: OpenAI reconstruction did not improve LaTeX (confidence: {confidence:.2f})")
                # Return pre-cleaned version (with truncation fixes) as fallback
                if cleaned_latex != original_latex:
                    self.log.append("MANDATORY: Using pre-cleaned LaTeX (with truncation fixes) as fallback")
                    self.log.append(f"MANDATORY: Pre-cleaned LaTeX: {cleaned_latex[:100]}...")
                    return cleaned_latex
                return original_latex

        except (NameError, SyntaxError) as code_err:
            # Catch code execution errors specifically
            error_msg = str(code_err)
            self.log.append(f"MANDATORY: Code execution error: {error_msg}")
            self.log.append("ERROR: OpenAI response likely contains executable code")
            self.log.append("MANDATORY: Using pre-cleaned LaTeX (with truncation fixes and letter-by-letter fixes) as fallback")
            # Return the pre-cleaned version (with truncation fixes and letter-by-letter fixes) as fallback
            if cleaned_latex != original_latex:
                self.log.append(f"MANDATORY: Pre-cleaned LaTeX (with fixes): {cleaned_latex[:100]}...")
                # Re-check if cleaned version still has corruption - if not, it's usable
                is_still_corrupted, _ = detect_latex_corruption(cleaned_latex)
                has_still_hack, _ = has_spelling_hack(cleaned_latex)
                if not is_still_corrupted and not has_still_hack:
                    self.log.append("MANDATORY: Pre-cleaned LaTeX appears clean after fixes - using it")
                return cleaned_latex
            return original_latex
        except Exception as exc:
            error_msg = str(exc)
            self.log.append(f"MANDATORY: OpenAI cleanup failed: {error_msg}")
            
            # If error is about code execution (e.g., "name 's_1' is not defined"), 
            # it means OpenAI returned executable code instead of JSON
            if "is not defined" in error_msg or "NameError" in error_msg:
                self.log.append("ERROR: OpenAI returned executable code instead of JSON - this should not happen")
                self.log.append("MANDATORY: Using pre-cleaned LaTeX (with truncation fixes and letter-by-letter fixes) as fallback")
                # Return the pre-cleaned version (with truncation fixes and letter-by-letter fixes) as fallback
                if cleaned_latex != original_latex:
                    self.log.append(f"MANDATORY: Pre-cleaned LaTeX (with fixes): {cleaned_latex[:100]}...")
                    # Re-check if cleaned version still has corruption - if not, it's usable
                    is_still_corrupted, _ = detect_latex_corruption(cleaned_latex)
                    has_still_hack, _ = has_spelling_hack(cleaned_latex)
                    if not is_still_corrupted and not has_still_hack:
                        self.log.append("MANDATORY: Pre-cleaned LaTeX appears clean after fixes - using it")
                    return cleaned_latex
                return original_latex
            
            # On other errors, return pre-cleaned version if it was modified, otherwise original
            if cleaned_latex != original_latex:
                self.log.append("MANDATORY: Using pre-cleaned LaTeX (with truncation fixes) as fallback after OpenAI error")
                self.log.append(f"MANDATORY: Pre-cleaned LaTeX: {cleaned_latex[:100]}...")
                return cleaned_latex
            return original_latex
    
    def _mandatory_openai_mathml_fix(self, latex: str, corrupted_mathml: str, violations: List[str]) -> Optional[dict]:
        """
        DEPRECATED: OpenAI should NOT generate or fix MathML.
        
        This method is kept for backward compatibility but should not be used.
        MathML must come from deterministic LaTeX‚ÜíMathML compiler only.
        """
        self.log.append("üö´ ERROR: _mandatory_openai_mathml_fix called - OpenAI should NOT generate/fix MathML")
        self.log.append("üö´ RULE: MathML must come from deterministic LaTeX‚ÜíMathML compiler")
        return None
    
    def _try_ai_fallback_strict(self, latex: str, mathml: str) -> Optional[dict]:
        """
        DEPRECATED: OpenAI should NOT generate or fix MathML.
        
        This method is kept for backward compatibility but should not be used.
        MathML must come from deterministic LaTeX‚ÜíMathML compiler only.
        OpenAI is ONLY used for LaTeX semantic rewriting.
        """
        self.log.append("üö´ ERROR: _try_ai_fallback_strict called - OpenAI should NOT generate/fix MathML")
        self.log.append("üö´ RULE: MathML must come from deterministic LaTeX‚ÜíMathML compiler")
        self.log.append("üö´ RULE: OpenAI is ONLY used for LaTeX semantic rewriting")
        return None

