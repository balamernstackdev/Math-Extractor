
"""
SAFE OCR MathML Cleaner
-----------------------

This cleaner performs ONLY:
- XML cleaning
- removal of illegal characters
- normalization of MathML tokens
- removing broken wrapper tags
- flattening redundant mrow
- trimming noise nodes

This cleaner NEVER:
- guesses equations
- rewrites formulas
- inserts missing symbols
- builds new subscripts/superscripts
- reconstructs math structure

It is 100% SAFE for production use.
"""

from __future__ import annotations
import re
import xml.etree.ElementTree as ET

from core.logger import logger

ET.register_namespace("", "http://www.w3.org/1998/Math/MathML")


class OCRMathMLCleaner:
    """Safe cleaning of OCR-damaged MathML."""

    # Characters that must not appear inside MathML text
    NOISE_CHARS = set([
        "€","¢","£","¥","©","®","™","°",
        "«","»","…","–","—","‚","„","›","‹",
        "?", "#"
    ])

    # Allowed MathML operator characters
    VALID_OPERATORS = set([
        "+","-","*","/","=",
        "<",">","≤","≥","≠",
        "∑","∫","∂","∞","∏",
        "∪","∩","⊆","⊇","⊂","⊃",
        "→","←","↔"
    ])

    def clean(self, corrupted: str) -> dict[str, str]:
        """Main entry: clean OCR MathML safely."""
        logger.info("Cleaning OCR MathML (safe mode)")

        try:
            root = ET.fromstring(corrupted)
        except Exception:
            logger.warning("MathML not parseable, wrapping in <math>.")
            wrapped = f'<math xmlns="http://www.w3.org/1998/Math/MathML">{corrupted}</math>'
            try:
                root = ET.fromstring(wrapped)
            except Exception:
                logger.error("OCR MathML completely unreadable. Returning minimal wrapper.")
                return {
                    "mathml": '<math xmlns="http://www.w3.org/1998/Math/MathML"></math>',
                    "latex": "",            # not generated by cleaner
                    "elements": {},
                }

        self._clean_tree(root)

        mathml_string = ET.tostring(root, encoding="unicode")

        return {
            "mathml": mathml_string,
            "latex": "",       # safest: this cleaner does not generate LaTeX
            "elements": {},    # optional: extraction removed for stability
        }

    # -----------------------------------------------------------
    # Safe tree cleaning
    # -----------------------------------------------------------
    def _clean_tree(self, root: ET.Element) -> None:
        """Apply minimal, safe cleanup."""
        for node in list(root.iter()):
            self._clean_node_text(node)
            self._remove_empty_wrapper(node)
            self._flatten_single_child_mrow(node)
            self._strip_noise_nodes(node)

    # -----------------------------------------------------------
    # TEXT CLEANING
    # -----------------------------------------------------------
    def _clean_node_text(self, node: ET.Element) -> None:
        """Clean illegal characters inside <mi>, <mo>, <mtext>."""
        if node.text:
            cleaned = "".join(ch for ch in node.text if ch not in self.NOISE_CHARS)
            node.text = cleaned.strip()

        if node.tail:
            cleaned = "".join(ch for ch in node.tail if ch not in self.NOISE_CHARS)
            node.tail = cleaned.strip()

    # -----------------------------------------------------------
    # REMOVE EMPTY TAGS
    # -----------------------------------------------------------
    def _remove_empty_wrapper(self, node: ET.Element) -> None:
        """Remove useless empty elements."""
        for child in list(node):
            if (
                (child.text is None or not child.text.strip()) and
                len(child) == 0 and
                (child.tail is None or not child.tail.strip())
            ):
                node.remove(child)

    # -----------------------------------------------------------
    # FLATTEN <mrow> WITH SINGLE CHILD
    # -----------------------------------------------------------
    def _flatten_single_child_mrow(self, node: ET.Element) -> None:
        """Replace <mrow><mi>x</mi></mrow> → <mi>x</mi>."""
        if node.tag.endswith("mrow") and len(node) == 1:
            child = node[0]
            node.tag = child.tag
            node.text = child.text
            node[:] = list(child)
            node.tail = child.tail

    # -----------------------------------------------------------
    # REMOVE PURE NOISE NODES (safe)
    # -----------------------------------------------------------
    def _strip_noise_nodes(self, node: ET.Element) -> None:
        """Remove useless <mi> or <mo> noise (single dot, stray slash, etc.)."""
        cleaned_children = []
        for child in node:
            content = (child.text or "").strip()
            tag = child.tag.split("}", 1)[-1]

            if tag in {"mi", "mo"}:
                # Remove completely meaningless symbols
                if content in {"", ".", ";", ",", "\\"}:
                    continue
                # Remove single letters that appear before closing bracket (OCR artifact)
                if content.isalpha() and len(content) == 1:
                    # Example: unwanted 'l' before ']'
                    # Only remove if followed by a bracket node
                    idx = list(node).index(child)
                    if idx + 1 < len(node):
                        nxt = node[idx + 1]
                        if nxt.tag.endswith("mo") and (nxt.text or "").strip() in {"]", ")"}:
                            continue

            cleaned_children.append(child)

        node[:] = cleaned_children


# """Clean corrupted OCR MathML and convert to clean LaTeX and MathML."""
# from __future__ import annotations

# import re
# import xml.etree.ElementTree as ET
# from typing import Any

# from core.logger import logger

# # Register MathML namespace
# ET.register_namespace("", "http://www.w3.org/1998/Math/MathML")


# class OCRMathMLCleaner:
#     """Clean corrupted OCR MathML and extract mathematical elements."""

#     # Common OCR error patterns: (corrupted, correct)
#     OCR_PATTERNS = [
#         (r"l\s*é\s*\]", "[l]"),  # "l é ]" → "[l]"
#         (r"l\s*é\s*\]", "[l]"),  # "l é ]" → "[l]"
#         (r"€", ""),  # Euro symbol
#         (r"¢", ""),  # Cent symbol
#         (r"»", ""),  # Right angle quote
#         (r"«", ""),  # Left angle quote
#         (r"é", "e"),  # Accented e
#         (r"É", "E"),  # Accented E
#         (r"à", "a"),  # Accented a
#         (r"è", "e"),  # Accented e
#         (r"ù", "u"),  # Accented u
#         (r"ô", "o"),  # Accented o
#         (r"î", "i"),  # Accented i
#         (r"ç", "c"),  # Cedilla c
#         (r"ñ", "n"),  # Tilde n
#         (r"α", "alpha"),  # Greek alpha (common OCR mistake)
#         (r"β", "beta"),  # Greek beta
#         (r"γ", "gamma"),  # Greek gamma
#         (r"π", "pi"),  # Greek pi
#         (r"θ", "theta"),  # Greek theta
#         (r"λ", "lambda"),  # Greek lambda
#         (r"μ", "mu"),  # Greek mu
#         (r"σ", "sigma"),  # Greek sigma
#         (r"∞", "infty"),  # Infinity symbol
#         (r"∑", "sum"),  # Sum symbol
#         (r"∫", "int"),  # Integral symbol
#         (r"√", "sqrt"),  # Square root
#         (r"≤", "le"),  # Less than or equal
#         (r"≥", "ge"),  # Greater than or equal
#         (r"≠", "ne"),  # Not equal
#         (r"≈", "approx"),  # Approximately
#         (r"±", "pm"),  # Plus minus
#         (r"×", "times"),  # Multiplication
#         (r"÷", "div"),  # Division
#         (r"∂", "partial"),  # Partial derivative
#         (r"∇", "nabla"),  # Nabla
#         (r"∏", "prod"),  # Product
#         (r"∏", "prod"),  # Product
#     ]

#     # Stray characters to remove
#     STRAY_CHARS = set([
#         "€", "é", "¢", "»", "«", "à", "è", "ù", "ô", "î", "ç", "ñ",
#         "€", "£", "¥", "§", "©", "®", "™", "°", "²", "³", "¹", "º",
#         "¿", "¡", "«", "»", "„", "‚", "‹", "›", "—", "–", "…",
#     ])

#     # Mathematical operators
#     OPERATORS = {
#         "+", "-", "*", "/", "=", "<", ">", "≤", "≥", "≠", "≈", "±",
#         "×", "÷", "∑", "∏", "∫", "∂", "∇", "√", "∞", "→", "←", "↔",
#         "∧", "∨", "¬", "∈", "∉", "⊂", "⊃", "⊆", "⊇", "∪", "∩",
#     }

#     # Common variable patterns
#     VARIABLE_PATTERN = re.compile(r"[a-zA-Z][a-zA-Z0-9]*")

#     def __init__(self) -> None:
#         """Initialize the OCR MathML cleaner."""
#         self.extracted_elements: dict[str, Any] = {
#             "variables": [],
#             "subscripts": [],
#             "superscripts": [],
#             "operators": [],
#         }

#     def clean(self, corrupted_mathml: str) -> dict[str, str]:
#         """Clean corrupted OCR MathML and return clean LaTeX and MathML.
        
#         Args:
#             corrupted_mathml: Corrupted MathML string from OCR
            
#         Returns:
#             Dictionary with keys:
#                 - "latex": Clean LaTeX equation
#                 - "mathml": Clean MathML
#                 - "elements": Extracted mathematical elements
#         """
#         logger.info("Cleaning corrupted OCR MathML")
        
#         # Step 1: Remove stray characters
#         cleaned = self._remove_stray_chars(corrupted_mathml)
        
#         # Step 2: Fix common OCR patterns
#         cleaned = self._fix_ocr_patterns(cleaned)
        
#         # Step 3: Parse and clean MathML structure
#         try:
#             cleaned_mathml = self._clean_mathml_structure(cleaned)
#         except Exception as e:
#             logger.warning("Failed to parse MathML, using text-based cleaning: %s", e)
#             cleaned_mathml = self._clean_mathml_text(cleaned)
        
#         # Step 4: Extract mathematical elements
#         self._extract_elements(cleaned_mathml)
        
#         # Step 5: Convert to LaTeX
#         latex = self._mathml_to_latex(cleaned_mathml)
        
#         return {
#             "latex": latex,
#             "mathml": cleaned_mathml,
#             "elements": self.extracted_elements.copy(),
#         }

#     def _remove_stray_chars(self, text: str) -> str:
#         """Remove stray characters that are OCR errors."""
#         result = []
#         for char in text:
#             if char not in self.STRAY_CHARS:
#                 result.append(char)
#             else:
#                 logger.debug("Removed stray character: %s", char)
#         return "".join(result)

#     def _fix_ocr_patterns(self, text: str) -> str:
#         """Fix common OCR error patterns."""
#         result = text
#         for pattern, replacement in self.OCR_PATTERNS:
#             result = re.sub(pattern, replacement, result, flags=re.IGNORECASE)
#         return result

#     def _clean_mathml_structure(self, mathml: str) -> str:
#         """Clean MathML XML structure."""
#         try:
#             # Try to parse as XML
#             root = ET.fromstring(mathml)
            
#             # Remove empty elements
#             self._remove_empty_elements(root)
            
#             # Remove nested repeated tags
#             self._remove_nested_duplicates(root)
            
#             # Clean up structure
#             self._clean_structure(root)

#             # Pre-clean tokens and reconstruct grammar before export
#             self._preclean_and_reconstruct(root)
            
#             # Convert back to string
#             ET.indent(root, space="  ")
#             cleaned = ET.tostring(root, encoding="unicode", method="xml")
            
#             # Ensure namespace
#             if 'xmlns="http://www.w3.org/1998/Math/MathML"' not in cleaned:
#                 cleaned = cleaned.replace('<math', '<math xmlns="http://www.w3.org/1998/Math/MathML"')
            
#             return cleaned
            
#         except ET.ParseError as e:
#             logger.warning("MathML parse error: %s", e)
#             # Try to extract math content from malformed XML
#             return self._clean_mathml_text(mathml)

#     def _clean_mathml_text(self, text: str) -> str:
#         """Fallback: clean MathML as text when XML parsing fails."""
#         # Remove stray characters from tag content
#         cleaned = re.sub(r">([^<]*?)<", lambda m: ">" + self._clean_text_content(m.group(1)) + "<", text)
        
#         # Try to fix common XML issues
#         cleaned = re.sub(r"<([^/>]+?)/>", r"<\1></\1>", cleaned)  # Fix self-closing tags
#         cleaned = re.sub(r"<([^>]+?)>([^<]*?)</\1>", r"<\1>\2</\1>", cleaned)  # Fix mismatched tags
        
#         # Ensure math wrapper
#         if not cleaned.strip().startswith("<math"):
#             cleaned = f'<math xmlns="http://www.w3.org/1998/Math/MathML">{cleaned}</math>'
        
#         return cleaned

#     def _clean_text_content(self, text: str) -> str:
#         """Clean text content within tags."""
#         # Remove stray characters
#         result = text
#         for char in self.STRAY_CHARS:
#             result = result.replace(char, "")
#         # Normalize common OCR relation/punctuation noise
#         result = result.replace(";", "")
#         return result.strip()

#     # --- Pre-clean + grammar reconstruction helpers ---

#     def _preclean_and_reconstruct(self, root: ET.Element) -> None:
#         """Normalize OCR tokens and rebuild basic MathML grammar.

#         This step fixes common OCR damage before converting back to LaTeX:
#         - Normalize equivalent tokens (-, ., − → -)
#         - Remove noise characters (#, stray .)
#         - Fix unmatched brackets within rows
#         - Rebuild sub/sup blocks (including ranges like _i=1^K)
#         - Attach limits to union/sum/product symbols
#         """
#         self._normalize_tokens(root)
#         self._remove_noise_nodes(root)
#         self._repair_brackets(root)
#         self._reconstruct_script_blocks(root)
#         self._flatten_singleton_mrows(root)
#         self._repair_channel_sum_template(root)

#     def _repair_channel_sum_template(self, root: ET.Element) -> None:
#         """Heuristic repair for channel equations like Y_j[t] = sum h_{i,j}[t] X_i[t] + Z_j[t]."""

#         def ensure_bracket_t(seq: list[ET.Element], insert_at: int) -> list[ET.Element]:
#             """Insert [t] at a position and return updated list."""
#             bracket = [
#                 ET.Element("mo", **{"stretchy": "false"}),
#                 ET.Element("mi"),
#                 ET.Element("mo", **{"stretchy": "false"}),
#             ]
#             bracket[0].text = "["
#             bracket[1].text = "t"
#             bracket[2].text = "]"
#             return seq[:insert_at] + bracket + seq[insert_at:]

#         def build_sum_limits() -> ET.Element:
#             munder = ET.Element("munder")
#             mo_sum = ET.Element("mo")
#             mo_sum.text = "∑"
#             munder.append(mo_sum)
#             under = ET.Element("mrow")
#             for txt in ["i", "∈", "I", "(", "j", ")"]:
#                 el = ET.Element("mo" if txt in {"∈", "(", ")"} else "mi")
#                 el.text = txt
#                 under.append(el)
#             munder.append(under)
#             return munder

#         def replace_msub(base_char: str, subs: list[str]) -> ET.Element:
#             msub = ET.Element("msub")
#             mi_base = ET.Element("mi")
#             mi_base.text = base_char
#             msub.append(mi_base)
#             subrow = ET.Element("mrow")
#             for idx, s in enumerate(subs):
#                 el = ET.Element("mi")
#                 el.text = s
#                 subrow.append(el)
#                 if idx == 0 and len(subs) > 1:
#                     comma = ET.Element("mo")
#                     comma.text = ","
#                     subrow.append(comma)
#             msub.append(subrow)
#             return msub

#         for node in root.iter():
#             if self._tag(node) not in {"mrow", "math"}:
#                 continue
#             children = list(node)

#             # Skip if already well-structured with sum
#             has_sum = any(self._tag(c) == "mo" and (c.text or "").strip() == "∑" for c in children)
#             has_munder_sum = any(self._tag(c) == "munder" for c in children)

#             # Repair Y_j[t]
#             for idx, child in enumerate(children):
#                 if self._tag(child) == "msub" and len(child) >= 2 and (child[0].text or "").strip() == "Y":
#                     # Ensure sub is just 'j'
#                     child[1].clear()
#                     mi_j = ET.Element("mi")
#                     mi_j.text = "j"
#                     child[1].append(mi_j)
#                     # Ensure bracket [t] after Y_j
#                     tail_slice = children[idx + 1 : idx + 4]
#                     has_bracket = any(
#                         self._tag(e) == "mo" and (e.text or "").strip() in {"[", "]"} for e in tail_slice
#                     )
#                     if not has_bracket:
#                         children = ensure_bracket_t(children, idx + 1)
#                     break

#             # Insert sum block if missing but we see h and X
#             if not has_sum and not has_munder_sum:
#                 has_h = any((self._tag(c) == "msub" and (c[0].text or "").strip() == "h") or
#                             (self._tag(c) == "mi" and (c.text or "").strip() == "h") for c in children)
#                 has_x = any((self._tag(c) == "msub" and (c[0].text or "").strip() == "X") or
#                             (self._tag(c) == "mi" and (c.text or "").strip() == "X") for c in children)
#                 if has_h and has_x:
#                     # Find position after '=' to insert sum
#                     insert_pos = 0
#                     for idx, c in enumerate(children):
#                         if self._tag(c) == "mo" and (c.text or "").strip() == "=":
#                             insert_pos = idx + 1
#                             break
#                     children = children[:insert_pos] + [build_sum_limits()] + children[insert_pos:]

#             # Normalize h_{i,j}[t] and X_i[t]
#             for idx, child in enumerate(children):
#                 if self._tag(child) == "msub" and (child[0].text or "").strip() == "h":
#                     children[idx] = replace_msub("h", ["i", "j"])
#                     children = ensure_bracket_t(children, idx + 1)
#                 if self._tag(child) == "msub" and (child[0].text or "").strip() == "X":
#                     children[idx] = replace_msub("X", ["i"])
#                     children = ensure_bracket_t(children, idx + 1)

#             # Normalize Z_j[t] and drop trailing numeric noise
#             for idx, child in enumerate(children):
#                 if self._tag(child) == "msub" and (child[0].text or "").strip() == "Z":
#                     children[idx] = replace_msub("Z", ["j"])
#                     children = ensure_bracket_t(children, idx + 1)
#                     # Drop any numeric/bracket noise after Z
#                     if idx + 4 < len(children):
#                         children = children[: idx + 4]
#                     break

#             node[:] = children

#     def _tag(self, element: ET.Element) -> str:
#         """Return the tag name without namespace."""
#         return element.tag.split("}", 1)[-1] if "}" in element.tag else element.tag

#     def _normalize_tokens(self, element: ET.Element) -> None:
#         """Normalize common OCR variants for operator/number tokens."""
#         replacements = {
#             "−": "-",
#             "–": "-",
#             "—": "-",
#             "·": ".",
#             "∙": ".",
#             "•": ".",
#         }
#         for child in element.iter():
#             if child.text:
#                 text = child.text
#                 for bad, good in replacements.items():
#                     text = text.replace(bad, good)
#                 # Convert OCR '>' that often misreads '=' in equations
#                 if self._tag(child) == "mo" and text.strip() == ">":
#                     text = "="
#                 # Normalize stray LaTeX-like escapes that leaked into MathML text
#                 if text.strip() == r"\P":
#                     text = "P"
#                 # Normalize union misread as plain U
#                 if text.strip() == "U":
#                     text = "∪"
#                 child.text = text

#     def _remove_noise_nodes(self, element: ET.Element) -> None:
#         """Drop obvious noise nodes (#, orphan dots not part of numbers)."""
#         for parent in list(element.iter()):
#             children = list(parent)
#             new_children = []
#             get_tag = lambda n: self._tag(n) if n is not None else ""
#             for idx, child in enumerate(children):
#                 tag = self._tag(child)
#                 content = (child.text or "").strip() if child.text else ""
#                 if tag in {"mi", "mo", "mtext"}:
#                     # Remove hash or empty noise
#                     if content in {"#", "", "?", ":"}:
#                         continue
#                     # Remove stray punctuation noise
#                     if content in {";", ":"}:
#                         continue
#                     # Remove stray single backslash tokens
#                     if content == "\\":
#                         continue
#                     # Remove stray dot not between numbers
#                     if content == ".":
#                         prev = children[idx - 1] if idx > 0 else None
#                         nxt = children[idx + 1] if idx + 1 < len(children) else None
#                         if not (self._is_number_node(prev) and self._is_number_node(nxt)):
#                             continue
#                     # Drop stray single-letter noise like 'l' before a closing bracket
#                     if content.lower() == "l":
#                         nxt = children[idx + 1] if idx + 1 < len(children) else None
#                         if self._tag(nxt) == "mo" and (nxt.text or "").strip() == "]":
#                             continue
#                 # Drop isolated small digits likely OCR noise between identifiers
#                 if tag == "mn":
#                     if content.isdigit():
#                         prev = children[idx - 1] if idx > 0 else None
#                         nxt = children[idx + 1] if idx + 1 < len(children) else None
#                         if get_tag(prev) == "mi" and get_tag(nxt) == "mi":
#                             continue
#                         # Drop digit noise sitting between brackets (e.g., "2" in "2[e]")
#                         if get_tag(prev) == "mo" and (prev.text or "").strip() in {"[", "("}:
#                             if get_tag(nxt) in {"mo", "mi"}:
#                                 continue
#                 new_children.append(child)
#             if len(new_children) != len(children):
#                 parent[:] = new_children

#     def _flatten_singleton_mrows(self, element: ET.Element) -> None:
#         """Simplify mrow wrappers that only hold a single identifier."""
#         for parent in element.iter():
#             children = list(parent)
#             changed = False
#             for idx, child in enumerate(children):
#                 if self._tag(child) == "mrow" and len(child) == 1 and self._tag(child[0]) in {"mi", "mn", "mo"}:
#                     # Replace the mrow with its single child
#                     children[idx] = child[0]
#                     changed = True
#             if changed:
#                 parent[:] = children

#     def _is_number_node(self, node: ET.Element | None) -> bool:
#         """Check if node represents a numeric token."""
#         if node is None:
#             return False
#         if self._tag(node) == "mn":
#             return True
#         if self._tag(node) == "mi":
#             txt = (node.text or "").strip()
#             return txt.isdigit()
#         return False

#     def _repair_brackets(self, element: ET.Element) -> None:
#         """Ensure brackets are balanced inside each row-like container."""
#         open_set = {"(", "[", "{", "|"}
#         close_map = {")": "(", "]": "[", "}": "{", "|": "|"}
#         open_to_close = {"(": ")", "[": "]", "{": "}", "|": "|"}

#         def fix_row(row: ET.Element) -> None:
#             children = list(row)
#             new_children = []
#             stack: list[str] = []
#             for child in children:
#                 child_tag = self._tag(child)
#                 text = (child.text or "").strip() if child_tag == "mo" else None
#                 if child_tag == "mo" and text in open_set:
#                     stack.append(text)
#                     new_children.append(child)
#                 elif child_tag == "mo" and text in close_map:
#                     if stack and stack[-1] == close_map[text]:
#                         stack.pop()
#                         new_children.append(child)
#                     else:
#                         # Unmatched closing; drop it
#                         continue
#                 else:
#                     new_children.append(child)
#             # Close any remaining opens
#             while stack:
#                 opener = stack.pop()
#                 closer = ET.Element("mo")
#                 closer.text = open_to_close[opener]
#                 new_children.append(closer)
#             if len(new_children) != len(children):
#                 row[:] = new_children

#         for node in element.iter():
#             if self._tag(node) in {"mrow", "math"}:
#                 fix_row(node)

#     def _reconstruct_script_blocks(self, element: ET.Element) -> None:
#         """Rebuild sub/sup and range blocks from flat operator tokens."""
#         for node in element.iter():
#             if self._tag(node) not in {"mrow", "math"}:
#                 continue
#             children = list(node)
#             if not children:
#                 continue

#             new_children: list[ET.Element] = []
#             idx = 0
#             while idx < len(children):
#                 child = children[idx]

#                 # Handle sub/sup reconstruction on plain tokens
#                 if self._tag(child) == "mo" and (child.text or "").strip() in {"_", "^"} and new_children:
#                     op = (child.text or "").strip()
#                     base = new_children.pop()
#                     sub_node = None
#                     sup_node = None

#                     if op == "_" and idx + 1 < len(children):
#                         sub_node, consumed = self._collect_script_target(children, idx + 1)
#                         idx = consumed
#                         # Look ahead for paired superscript after subscript
#                         if idx < len(children) and self._tag(children[idx]) == "mo" and (children[idx].text or "").strip() == "^":
#                             sup_node, consumed = self._collect_script_target(children, idx + 1)
#                             idx = consumed
#                             new_children.append(self._build_subsup(base, sub_node, sup_node))
#                             continue
#                         new_children.append(self._build_sub(base, sub_node))
#                         continue

#                     if op == "^" and idx + 1 < len(children):
#                         sup_node, consumed = self._collect_script_target(children, idx + 1)
#                         idx = consumed
#                         new_children.append(self._build_sup(base, sup_node))
#                         continue

#                     # Fallback: if we could not consume targets, put base back
#                     new_children.append(base)
#                     idx += 1
#                     continue

#                 new_children.append(child)
#                 idx += 1

#             node[:] = new_children

#     def _collect_script_target(self, children: list[ET.Element], start_idx: int) -> tuple[ET.Element, int]:
#         """Collect a sub/sup target, grouping ranges like i=1 or i=1..K."""
#         collected: list[ET.Element] = []
#         idx = start_idx
#         stopper_tokens = {"^", "_", ",", ";", "(", ")"}
#         while idx < len(children):
#             candidate = children[idx]
#             text = (candidate.text or "").strip() if self._tag(candidate) == "mo" else None
#             if text in stopper_tokens:
#                 break
#             collected.append(candidate)
#             idx += 1

#             # For range reconstruction, stop after encountering relational operator with right operand
#             if text in {"=", "≤", "<", "≥", ">"} and idx < len(children):
#                 collected.append(children[idx])
#                 idx += 1
#                 break

#         target: ET.Element
#         if not collected:
#             target = ET.Element("mi")
#             target.text = ""
#         elif len(collected) == 1:
#             target = collected[0]
#         else:
#             target = ET.Element("mrow")
#             target.extend(collected)
#         return target, idx

#     def _build_sub(self, base: ET.Element, sub: ET.Element) -> ET.Element:
#         node = ET.Element("msub")
#         node.extend([base, sub])
#         return node

#     def _build_sup(self, base: ET.Element, sup: ET.Element) -> ET.Element:
#         node = ET.Element("msup")
#         node.extend([base, sup])
#         return node

#     def _build_subsup(self, base: ET.Element, sub: ET.Element, sup: ET.Element) -> ET.Element:
#         node = ET.Element("msubsup")
#         node.extend([base, sub, sup])
#         return node

#     def _remove_empty_elements(self, element: ET.Element) -> None:
#         """Recursively remove empty elements."""
#         # Process children first
#         for child in list(element):
#             self._remove_empty_elements(child)
            
#             # Remove if empty (no text, no children, or only whitespace)
#             if (
#                 (child.text is None or not child.text.strip())
#                 and len(child) == 0
#                 and (child.tail is None or not child.tail.strip())
#             ):
#                 element.remove(child)
#                 logger.debug("Removed empty element: %s", child.tag)

#     def _remove_nested_duplicates(self, element: ET.Element) -> None:
#         """Remove nested repeated tags (e.g., <mi><mi>x</mi></mi> → <mi>x</mi>)."""
#         for child in list(element):
#             self._remove_nested_duplicates(child)

#             tag = self._tag(child)
#             # If child has single child with same tag, flatten
#             if len(child) == 1 and self._tag(child[0]) == tag:
#                 # Move content up
#                 grandchild = child[0]
#                 child.text = grandchild.text
#                 child.tail = grandchild.tail
#                 # Move grandchildren up
#                 for gc in list(grandchild):
#                     child.append(gc)
#                 # Remove the duplicate
#                 child.remove(grandchild)
#                 logger.debug("Flattened nested duplicate: %s", child.tag)

#     def _clean_structure(self, element: ET.Element) -> None:
#         """Clean MathML structure recursively."""
#         for child in list(element):
#             self._clean_structure(child)

#             tag = self._tag(child)
#             # Remove empty subscripts/superscripts
#             if tag in ("msub", "msup", "msubsup"):
#                 # Check if subscript/superscript is empty
#                 if tag == "msub" and len(child) >= 2:
#                     if self._is_empty(child[1]):
#                         element.remove(child)
#                         logger.debug("Removed empty msub")
#                 elif tag == "msup" and len(child) >= 2:
#                     if self._is_empty(child[1]):
#                         element.remove(child)
#                         logger.debug("Removed empty msup")
#                 elif tag == "msubsup" and len(child) >= 3:
#                     if self._is_empty(child[1]) and self._is_empty(child[2]):
#                         element.remove(child)
#                         logger.debug("Removed empty msubsup")

#     def _is_empty(self, element: ET.Element) -> bool:
#         """Check if element is effectively empty."""
#         if element.text and element.text.strip():
#             return False
#         if len(element) > 0:
#             return False
#         if element.tail and element.tail.strip():
#             return False
#         return True

#     def _extract_elements(self, mathml: str) -> None:
#         """Extract mathematical elements from cleaned MathML."""
#         self.extracted_elements = {
#             "variables": [],
#             "subscripts": [],
#             "superscripts": [],
#             "operators": [],
#         }
        
#         try:
#             root = ET.fromstring(mathml)
#             self._extract_from_element(root)
#         except ET.ParseError:
#             # Fallback: extract from text
#             self._extract_from_text(mathml)

#     def _extract_from_element(self, element: ET.Element) -> None:
#         """Recursively extract elements from MathML tree."""
#         # Strip namespace if present (e.g., "{http://www.w3.org/1998/Math/MathML}mfrac")
#         tag = element.tag.split("}", 1)[-1] if "}" in element.tag else element.tag
        
#         # Extract variables (mi = math identifier)
#         if tag == "mi":
#             var = (element.text or "").strip()
#             if var and var not in self.extracted_elements["variables"]:
#                 self.extracted_elements["variables"].append(var)
        
#         # Extract subscripts
#         elif tag == "msub":
#             if len(element) >= 1:
#                 base = self._get_text_content(element[0])
#                 if len(element) >= 2:
#                     sub = self._get_text_content(element[1])
#                     self.extracted_elements["subscripts"].append({"base": base, "subscript": sub})
        
#         # Extract superscripts
#         elif tag == "msup":
#             if len(element) >= 1:
#                 base = self._get_text_content(element[0])
#                 if len(element) >= 2:
#                     sup = self._get_text_content(element[1])
#                     self.extracted_elements["superscripts"].append({"base": base, "superscript": sup})
        
#         # Extract operators (mo = math operator)
#         elif tag == "mo":
#             op = (element.text or "").strip()
#             if op and op not in self.extracted_elements["operators"]:
#                 self.extracted_elements["operators"].append(op)
        
#         # Recurse into children
#         for child in element:
#             self._extract_from_element(child)

#     def _extract_from_text(self, text: str) -> None:
#         """Fallback: extract elements from text using regex."""
#         # Extract variables
#         variables = self.VARIABLE_PATTERN.findall(text)
#         self.extracted_elements["variables"] = list(set(variables))
        
#         # Extract operators (simple pattern matching)
#         for op in self.OPERATORS:
#             if op in text:
#                 self.extracted_elements["operators"].append(op)

#     def _get_text_content(self, element: ET.Element) -> str:
#         """Get all text content from element and its children."""
#         text_parts = []
#         if element.text:
#             text_parts.append(element.text.strip())
#         for child in element:
#             text_parts.append(self._get_text_content(child))
#             if child.tail:
#                 text_parts.append(child.tail.strip())
#         return " ".join(filter(None, text_parts))

#     def _mathml_to_latex(self, mathml: str) -> str:
#         """Convert cleaned MathML to LaTeX."""
#         try:
#             root = ET.fromstring(mathml)
#             latex_parts = []
#             self._convert_element_to_latex(root, latex_parts)
#             return "".join(latex_parts)
#         except ET.ParseError:
#             # Fallback: try to extract LaTeX-like content
#             return self._extract_latex_from_text(mathml)

#     def _convert_element_to_latex(self, element: ET.Element, parts: list[str]) -> None:
#         """Convert MathML element to LaTeX recursively."""
#         tag = self._tag(element)
        
#         if tag == "math":
#             # Root element - process children
#             for child in element:
#                 self._convert_element_to_latex(child, parts)
        
#         elif tag == "mi":
#             # Math identifier (variable)
#             var = (element.text or "").strip()
#             # Map operator-like identifiers that leaked as mi
#             op_like_map = {"∪": r"\cup", "∩": r"\cap"}
#             if var in op_like_map:
#                 parts.append(op_like_map[var])
#             else:
#                 parts.append(var)
#             if element.tail:
#                 parts.append(element.tail.strip())
        
#         elif tag == "mn":
#             # Math number
#             num = (element.text or "").strip()
#             parts.append(num)
#             if element.tail:
#                 parts.append(element.tail.strip())
        
#         elif tag == "mo":
#             # Math operator
#             op = (element.text or "").strip()
#             # Convert special operators to LaTeX
#             op_map = {
#                 "×": r"\times",
#                 "÷": r"\div",
#                 "±": r"\pm",
#                 "≤": r"\leq",
#                 "≥": r"\geq",
#                 "≠": r"\neq",
#                 "≈": r"\approx",
#                 "∑": r"\sum",
#                 "sum": r"\sum",
#                 "∏": r"\prod",
#                 "prod": r"\prod",
#                 "∫": r"\int",
#                 "int": r"\int",
#                 "√": r"\sqrt",
#                 "sqrt": r"\sqrt",
#                 "∞": r"\infty",
#                 "∂": r"\partial",
#                 "∇": r"\nabla",
#                 "∈": r"\in",
#                 "∉": r"\notin",
#                 "⊂": r"\subset",
#                 "⊃": r"\supset",
#                 "⊆": r"\subseteq",
#                 "⊇": r"\supseteq",
#                 "∪": r"\cup",
#                 "∩": r"\cap",
#                 "∧": r"\land",
#                 "∨": r"\lor",
#                 "¬": r"\neg",
#                 "→": r"\to",
#                 "←": r"\leftarrow",
#                 "↔": r"\leftrightarrow",
#                 "∘": r"\circ", 
#                 "∙": r"\cdot",
#                 "•": r"\bullet",
#                 "∗": r"\ast",
#                 "∘": r"\circ",
#                 "∙": r"\cdot",
#                 "•": r"\bullet",
#                 "∗": r"\ast",
#                 "∘": r"\circ",
#                 "∙": r"\cdot",
#             }
#             parts.append(op_map.get(op, op))
#             if element.tail:
#                 parts.append(element.tail.strip())
        
#         elif tag == "mfrac":
#             # Fraction
#             if len(element) >= 2:
#                 parts.append(r"\frac{")
#                 self._convert_element_to_latex(element[0], parts)
#                 parts.append("}{")
#                 self._convert_element_to_latex(element[1], parts)
#                 parts.append("}")
        
#         elif tag == "msqrt":
#             # Square root
#             parts.append(r"\sqrt{")
#             for child in element:
#                 self._convert_element_to_latex(child, parts)
#             parts.append("}")
        
#         elif tag == "mroot":
#             # Root with index
#             if len(element) >= 2:
#                 parts.append(r"\sqrt[")
#                 self._convert_element_to_latex(element[1], parts)
#                 parts.append("]{")
#                 self._convert_element_to_latex(element[0], parts)
#                 parts.append("}")
        
#         elif tag == "msub":
#             # Subscript
#             if len(element) >= 2:
#                 self._convert_element_to_latex(element[0], parts)
#                 parts.append("_{")
#                 self._convert_element_to_latex(element[1], parts)
#                 parts.append("}")
        
#         elif tag == "msup":
#             # Superscript
#             if len(element) >= 2:
#                 self._convert_element_to_latex(element[0], parts)
#                 parts.append("^{")
#                 self._convert_element_to_latex(element[1], parts)
#                 parts.append("}")
        
#         elif tag == "msubsup":
#             # Subscript and superscript
#             if len(element) >= 3:
#                 self._convert_element_to_latex(element[0], parts)
#                 parts.append("_{")
#                 self._convert_element_to_latex(element[1], parts)
#                 parts.append("}^{")
#                 self._convert_element_to_latex(element[2], parts)
#                 parts.append("}")

#         elif tag in {"munder", "munderover"}:
#             # Operators with limits underneath (and possibly above)
#             # child0: base op, child1: under, child2: over (if munderover)
#             if len(element) >= 2:
#                 self._convert_element_to_latex(element[0], parts)
#                 parts.append("_{")
#                 self._convert_element_to_latex(element[1], parts)
#                 parts.append("}")
#                 if tag == "munderover" and len(element) >= 3:
#                     parts.append("^{")
#                     self._convert_element_to_latex(element[2], parts)
#                     parts.append("}")
        
#         elif tag == "mtext":
#             # Text
#             text = (element.text or "").strip()
#             parts.append(r"\text{" + text + "}")
#             if element.tail:
#                 parts.append(element.tail.strip())
        
#         elif tag == "mrow":
#             # Row (grouping)
#             for child in element:
#                 self._convert_element_to_latex(child, parts)
        
#         elif tag == "mtable":
#             # Table (matrix)
#             parts.append(r"\begin{matrix}")
#             for child in element:
#                 if child.tag == "mtr":
#                     row_parts = []
#                     for cell in child:
#                         if cell.tag == "mtd":
#                             cell_parts = []
#                             for cell_child in cell:
#                                 self._convert_element_to_latex(cell_child, cell_parts)
#                             row_parts.append("".join(cell_parts))
#                     if row_parts:
#                         parts.append(" & ".join(row_parts) + r" \\")
#             parts.append(r"\end{matrix}")
        
#         else:
#             # Unknown tag - process children
#             for child in element:
#                 self._convert_element_to_latex(child, parts)
#             if element.text:
#                 parts.append(element.text.strip())
#             if element.tail:
#                 parts.append(element.tail.strip())

#     def _extract_latex_from_text(self, text: str) -> str:
#         """Fallback: try to extract LaTeX from text."""
#         # Look for LaTeX-like patterns
#         latex_pattern = re.search(r"\\[a-zA-Z]+\{.*?\}", text)
#         if latex_pattern:
#             return latex_pattern.group(0)
        
#         # Otherwise, return cleaned text
#         cleaned = self._remove_stray_chars(text)
#         cleaned = self._fix_ocr_patterns(cleaned)
#         return cleaned

